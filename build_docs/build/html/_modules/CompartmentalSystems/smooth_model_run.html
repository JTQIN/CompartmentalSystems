
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CompartmentalSystems.smooth_model_run &#8212; CompartmentalSystems 1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for CompartmentalSystems.smooth_model_run</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module for numerical treatment of piece-wise continuous reservoir models.</span>

<span class="sd">An abstract </span>
<span class="sd">:class:`~.smooth_reservoir_model.SmoothReservoirModel` is </span>
<span class="sd">filled with life by giving initial values, a parameter set, a time grid, </span>
<span class="sd">and potentially additional involved functions to it.</span>

<span class="sd">The model can then be run and as long as the model is linear,</span>
<span class="sd">based on the state transition operator age and transit time</span>
<span class="sd">distributions can be computed.</span>

<span class="sd">Nonlinear models can be linearized along a solution trajectory.</span>

<span class="sd">Counting of compartment/pool/reservoir numbers start at zero and the </span>
<span class="sd">total number of pools is :math:`d`.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">matrix_power</span>

<span class="kn">import</span> <span class="nn">plotly.graph_objs</span> <span class="k">as</span> <span class="nn">go</span>

<span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">mpmath</span>
<span class="kn">from</span> <span class="nn">frozendict</span> <span class="kn">import</span> <span class="n">frozendict</span>

<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">lambdify</span><span class="p">,</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">latex</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">sstr</span><span class="p">,</span> <span class="n">solve</span><span class="p">,</span> \
                  <span class="n">ones</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">ImmutableMatrix</span>
<span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">UndefinedFunction</span>
<span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">_clash</span>
<span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="kn">import</span> <span class="n">pprint</span>

<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">inv</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">pinv</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">odeint</span><span class="p">,</span> <span class="n">quad</span> 
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span><span class="p">,</span> <span class="n">UnivariateSpline</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">newton</span><span class="p">,</span> <span class="n">brentq</span><span class="p">,</span> <span class="n">minimize</span>

<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="c1">#from testinfrastructure.helpers import pe</span>

<span class="kn">from</span> <span class="nn">.smooth_reservoir_model</span> <span class="kn">import</span> <span class="n">SmoothReservoirModel</span>
<span class="kn">from</span> <span class="nn">.model_run</span> <span class="kn">import</span> <span class="n">ModelRun</span>
<span class="kn">from</span> <span class="nn">.helpers_reservoir</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">deprecation_warning</span>
    <span class="p">,</span><span class="n">warning</span>
    <span class="p">,</span><span class="n">make_cut_func_set</span>
    <span class="p">,</span><span class="n">has_pw</span>
    <span class="p">,</span><span class="n">numsol_symbolic_system_old</span>
    <span class="p">,</span><span class="n">numsol_symbolical_system</span> 
    <span class="p">,</span><span class="n">arrange_subplots</span>
    <span class="p">,</span><span class="n">melt</span>
    <span class="p">,</span><span class="n">generalized_inverse_CDF</span>
    <span class="p">,</span><span class="n">draw_rv</span> 
    <span class="p">,</span><span class="n">stochastic_collocation_transform</span>
    <span class="p">,</span><span class="n">numerical_rhs</span>
    <span class="p">,</span><span class="n">numerical_rhs_old</span>
    <span class="p">,</span><span class="n">MH_sampling</span>
    <span class="p">,</span><span class="n">save_csv</span> 
    <span class="p">,</span><span class="n">load_csv</span>
    <span class="p">,</span><span class="n">stride</span>
    <span class="p">,</span><span class="n">f_of_t_maker</span>
    <span class="p">,</span><span class="n">const_of_t_maker</span>
    <span class="p">,</span><span class="n">numerical_function_from_expression</span>
    <span class="p">,</span><span class="n">x_phi_ode</span>
    <span class="p">,</span><span class="n">phi_tmax</span>
    <span class="p">,</span><span class="n">x_tmax</span>
    <span class="p">,</span><span class="n">print_quantile_error_statisctics</span>
    <span class="p">,</span><span class="n">custom_lru_cache_wrapper</span>
    <span class="p">,</span><span class="n">net_Us_from_discrete_Bs_and_xs</span>
    <span class="p">,</span><span class="n">net_Fs_from_discrete_Bs_and_xs</span>
    <span class="p">,</span><span class="n">net_Rs_from_discrete_Bs_and_xs</span>
    <span class="p">,</span><span class="n">check_parameter_dict_complete</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">.BlockIvp</span> <span class="kn">import</span> <span class="n">BlockIvp</span>
<span class="kn">from</span> <span class="nn">.myOdeResult</span> <span class="kn">import</span> <span class="n">solve_ivp_pwc</span>
<span class="kn">from</span> <span class="nn">.Cache</span> <span class="kn">import</span> <span class="n">Cache</span>

<div class="viewcode-block" id="Error"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.Error">[docs]</a><span class="k">class</span> <span class="nc">Error</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generic error occurring in this module.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="SmoothModelRun"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun">[docs]</a><span class="k">class</span> <span class="nc">SmoothModelRun</span><span class="p">(</span><span class="n">ModelRun</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for a model run based on a </span>
<span class="sd">    :class:`~.smooth_reservoir_model.SmoothReservoirModel`.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        model (:class:`~.smooth_reservoir_model.SmoothReservoirModel`): </span>
<span class="sd">            The reservoir model on which the model run bases.</span>
<span class="sd">        parameter_dict (dict): ``{x: y}`` with ``x`` being a SymPy symbol </span>
<span class="sd">            and ``y`` being a numerical value.</span>
<span class="sd">        start_values (numpy.array): The vector of start values.</span>
<span class="sd">        times (numpy.array): The time grid used for the simulation.</span>
<span class="sd">            Typically created by ``numpy.linspace``.</span>
<span class="sd">        func_set (dict): ``{f: func}`` with ``f`` being a SymPy symbol and </span>
<span class="sd">            ``func`` being a Python function. Defaults to ``dict()``.</span>

<span class="sd">    Pool counting starts with ``0``. In combined structures for pools and </span>
<span class="sd">    system, the system is at the position of a ``(d+1)`` st pool.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">parameter_dict</span><span class="p">,</span> 
                        <span class="n">start_values</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">func_set</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a SmoothModelRun instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (:class:`~.smooth_reservoir_model.SmoothReservoirModel`): </span>
<span class="sd">                The reservoir model on which the model run bases.</span>
<span class="sd">            parameter_dict (dict): ``{x: y}`` with ``x`` being a SymPy symbol </span>
<span class="sd">                and ``y`` being a numerical value.</span>
<span class="sd">            start_values (numpy.array): The vector of start values.</span>
<span class="sd">            times (numpy.array): The time grid used for the simulation.</span>
<span class="sd">                Typically created by ``numpy.linspace``.</span>
<span class="sd">            func_set (dict): ``{f: func}`` with ``f`` being a SymPy symbol and </span>
<span class="sd">                ``func`` being a Python function. Defaults to ``dict()``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If ``start_values`` is not a ``numpy.array``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we cannot use dict() as default because the test suite makes weird </span>
        <span class="c1"># things with it! But that is bad style anyways</span>
        <span class="k">if</span> <span class="n">parameter_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">parameter_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">func_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">func_set</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="c1"># check parameter_dict + func_set for completeness</span>
        <span class="n">free_symbols</span> <span class="o">=</span> <span class="n">check_parameter_dict_complete</span><span class="p">(</span>
                            <span class="n">model</span><span class="p">,</span> 
                            <span class="n">parameter_dict</span><span class="p">,</span> 
                            <span class="n">func_set</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">free_symbols</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">():</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Missing parameter values for &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">free_symbols</span><span class="p">)))</span>
        

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span> <span class="o">=</span> <span class="n">frozendict</span><span class="p">(</span><span class="n">parameter_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">times</span>
        <span class="c1"># make sure that start_values are an array,</span>
        <span class="c1"># even a one-dimensional one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_values</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,)</span>

        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">start_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;start_values should be a numpy array&quot;</span><span class="p">))</span>
        <span class="c1"># fixme mm: </span>
        <span class="c1">#func_set = {str(key): val for key, val in func_set.items()}</span>
        <span class="c1"># The conversion to string is not desirable here</span>
        <span class="c1"># should rather implement a stricter check (which fails at the moment because some tests use the old syntax</span>
        <span class="c1">#for f in func_set.keys():</span>
        <span class="c1">#    if not isinstance(f,UndefinedFunction):</span>
        <span class="c1">#        raise(Error(&quot;The keys of the func_set should be of type:  sympy.core.function.UndefinedFunction&quot;))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span> <span class="o">=</span> <span class="n">frozendict</span><span class="p">(</span><span class="n">func_set</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span>
                 <span class="p">[</span> <span class="s1">&#39;id(self)&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="s1">&#39;id(model)&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">))]</span>
                <span class="o">+</span><span class="p">[</span><span class="s2">&quot;id &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span>   <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
                <span class="o">+</span><span class="p">[</span><span class="s2">&quot;id &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span>   <span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
                <span class="p">)</span>  
 

        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The lengths of the time intervals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
<div class="viewcode-block" id="SmoothModelRun.B_func"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.B_func">[docs]</a>    <span class="k">def</span> <span class="nf">B_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec_sol_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Design comment:</span>
        <span class="c1"># Note that the vec_sol_func argument is necessary because</span>
        <span class="c1"># we have slight differences in solutions coming from different</span>
        <span class="c1"># numerical solutions. If we intended to apply B_func to </span>
        <span class="c1"># values not belonging to the solution, we would not do so</span>
        <span class="c1"># in an instace method but a separate function.</span>

        <span class="k">if</span> <span class="n">vec_sol_func</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vec_sol_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        
        <span class="c1"># we inject the solution into B to get the linearized version</span>
        <span class="n">srm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="n">srm</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">srm</span><span class="o">.</span><span class="n">state_vector</span><span class="p">)</span>
        <span class="n">numfun</span> <span class="o">=</span> <span class="n">numerical_function_from_expression</span><span class="p">(</span>
            <span class="n">srm</span><span class="o">.</span><span class="n">compartmental_matrix</span><span class="p">,</span>
            <span class="n">tup</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span>
        <span class="p">)</span>

        <span class="c1"># we want a function  that accepts a vector argument for x</span>
        
        <span class="k">def</span> <span class="nf">B_func</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">vec_sol_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numfun</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">B_func</span></div>
    
<div class="viewcode-block" id="SmoothModelRun.linearize_old"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.linearize_old">[docs]</a>    <span class="k">def</span> <span class="nf">linearize_old</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a linearized SmoothModelRun instance.</span>

<span class="sd">        Linearization happens along the solution trajectory. Only for linear </span>
<span class="sd">        systems all functionality is guaranteed,</span>
<span class="sd">        this is why nonlinear systems should be linearized first.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`SmoothModelRun`: A linearized version of the original </span>
<span class="sd">            :class:`SmoothModelRun`, with the solutions now being part </span>
<span class="sd">            of ``func_set``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sol_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol_funcs_old</span><span class="p">()</span>
        
        <span class="n">srm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">srm</span><span class="o">.</span><span class="n">xi_T_N_u_representation</span><span class="p">())</span>
        <span class="n">svec</span> <span class="o">=</span> <span class="n">srm</span><span class="o">.</span><span class="n">state_vector</span>

        <span class="n">symbolic_sol_funcs</span> <span class="o">=</span> <span class="p">{</span><span class="n">sv</span><span class="p">:</span> <span class="n">Function</span><span class="p">(</span><span class="n">sv</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sol&#39;</span><span class="p">)(</span><span class="n">srm</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">)</span> 
                                <span class="k">for</span> <span class="n">sv</span> <span class="ow">in</span> <span class="n">svec</span><span class="p">}</span>

        <span class="c1"># need to define a function_factory to create the function we need to </span>
        <span class="c1"># avoid late binding</span>
        <span class="c1"># with late binding pool will always be nr_pools and always the last </span>
        <span class="c1"># function will be used!</span>
        <span class="k">def</span> <span class="nf">func_maker</span><span class="p">(</span><span class="n">pool</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">sol_funcs</span><span class="p">[</span><span class="n">pool</span><span class="p">](</span><span class="n">t</span><span class="p">)</span>

            <span class="k">return</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="n">sol_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">sstr</span><span class="p">(</span><span class="n">symbolic_sol_funcs</span><span class="p">[</span><span class="n">svec</span><span class="p">[</span><span class="n">pool</span><span class="p">]])</span>
            <span class="n">sol_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_maker</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>


        <span class="n">linearized_B</span> <span class="o">=</span> <span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">symbolic_sol_funcs</span><span class="p">)</span>
        <span class="n">linearized_u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">symbolic_sol_funcs</span><span class="p">)</span>

        <span class="n">func_set</span><span class="o">=</span><span class="n">frozendict</span><span class="p">({</span><span class="n">key</span><span class="p">:</span><span class="n">val</span> <span class="k">for</span> <span class="n">mydict</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="p">,</span><span class="n">sol_dict</span><span class="p">]</span>
                                     <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="n">mydict</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>  

        <span class="n">cl</span><span class="o">=</span><span class="n">srm</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">linearized_srm</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">from_B_u</span><span class="p">(</span>
            <span class="n">srm</span><span class="o">.</span><span class="n">state_vector</span><span class="p">,</span> 
            <span class="n">srm</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,</span> 
            <span class="n">linearized_B</span><span class="p">,</span> 
            <span class="n">linearized_u</span>
        <span class="p">)</span>      

        <span class="n">linearized_smr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">linearized_srm</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> 
            <span class="n">func_set</span><span class="o">=</span><span class="n">func_set</span>
        <span class="p">)</span>
 
        <span class="k">return</span> <span class="n">linearized_smr</span></div>


<div class="viewcode-block" id="SmoothModelRun.linearize"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.linearize">[docs]</a>    <span class="k">def</span> <span class="nf">linearize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a linearized SmoothModelRun instance.</span>

<span class="sd">        Linearization happens along the solution trajectory. Only for linear </span>
<span class="sd">        systems all functionality is guaranteed,</span>
<span class="sd">        this is why nonlinear systems should be linearized first.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`SmoothModelRun`: A linearized version of the original </span>
<span class="sd">            :class:`SmoothModelRun`, with the solutions now being part </span>
<span class="sd">            of ``func_set``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#sol_funcs = self.sol_funcs()</span>
        <span class="n">sol_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol_funcs</span><span class="p">()</span>
        
        <span class="n">srm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">srm</span><span class="o">.</span><span class="n">xi_T_N_u_representation</span><span class="p">()</span>
        <span class="n">svec</span> <span class="o">=</span> <span class="n">srm</span><span class="o">.</span><span class="n">state_vector</span>

        <span class="n">symbolic_sol_funcs</span> <span class="o">=</span> <span class="p">{</span><span class="n">sv</span><span class="p">:</span> <span class="n">Function</span><span class="p">(</span><span class="n">sv</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sol&#39;</span><span class="p">)(</span><span class="n">srm</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">)</span> 
                                <span class="k">for</span> <span class="n">sv</span> <span class="ow">in</span> <span class="n">svec</span><span class="p">}</span>

        <span class="c1"># need to define a function_factory to create the function we need to </span>
        <span class="c1"># avoid late binding</span>
        <span class="c1"># with late binding pool will always be nr_pools and always the last </span>
        <span class="c1"># function will be used!</span>
        <span class="k">def</span> <span class="nf">func_maker</span><span class="p">(</span><span class="n">pool</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">sol_funcs</span><span class="p">[</span><span class="n">pool</span><span class="p">](</span><span class="n">t</span><span class="p">)</span>

            <span class="k">return</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="n">sol_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">sstr</span><span class="p">(</span><span class="n">symbolic_sol_funcs</span><span class="p">[</span><span class="n">svec</span><span class="p">[</span><span class="n">pool</span><span class="p">]])</span>
            <span class="n">sol_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_maker</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>


        <span class="n">linearized_B</span> <span class="o">=</span> <span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">symbolic_sol_funcs</span><span class="p">)</span>
        <span class="n">linearized_u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">symbolic_sol_funcs</span><span class="p">)</span>

        <span class="n">func_set</span><span class="o">=</span><span class="n">frozendict</span><span class="p">({</span><span class="n">key</span><span class="p">:</span><span class="n">val</span> <span class="k">for</span> <span class="n">mydict</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="p">,</span><span class="n">sol_dict</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="n">mydict</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>  
        <span class="c1">#func_set = self.func_set</span>
        <span class="c1">#func_set.update(sol_dict)</span>

        <span class="n">cl</span> <span class="o">=</span> <span class="n">srm</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">linearized_srm</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">from_B_u</span><span class="p">(</span>
            <span class="n">srm</span><span class="o">.</span><span class="n">state_vector</span><span class="p">,</span> 
            <span class="n">srm</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,</span> 
            <span class="n">linearized_B</span><span class="p">,</span> 
            <span class="n">linearized_u</span>
        <span class="p">)</span>      

        <span class="n">linearized_smr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">linearized_srm</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> 
            <span class="n">func_set</span><span class="o">=</span><span class="n">func_set</span>
        <span class="p">)</span>
 
        <span class="k">return</span> <span class="n">linearized_smr</span></div>

<div class="viewcode-block" id="SmoothModelRun.moments_from_densities"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.moments_from_densities">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="c1">#fixme mm 2018-9-5:</span>
    <span class="c1"># Why is this is mehtod of class SmoothModelRun?</span>
    <span class="c1"># It does not rely on the class definition in any </span>
    <span class="c1"># way. </span>
    <span class="c1"># Is it because the helper module is not exposed in the API?</span>
    <span class="k">def</span> <span class="nf">moments_from_densities</span><span class="p">(</span><span class="n">max_order</span><span class="p">,</span> <span class="n">densities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the moments up to max_order of the given densities.</span>

<span class="sd">        Args:</span>
<span class="sd">            max_order (int): The highest order up to which moments are </span>
<span class="sd">                to be computed.</span>
<span class="sd">            densities (numpy.array): Each entry is a Python function of one </span>
<span class="sd">                variable (age) that represents a probability density function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: moments x pools, containing the moments of the given </span>
<span class="sd">            densities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">densities</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">kth_moment</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">kth_moment_pool</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">pool</span><span class="p">):</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">densities</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">**</span><span class="n">k</span><span class="o">*</span><span class="n">densities</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                            <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kth_moment_pool</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">pool</span><span class="p">)</span> <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kth_moment</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_order</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span></div>



    <span class="c1">########## public methods and properties ########## </span>

    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nr_pools</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int: Return the number of pools involved in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nr_pools</span>

<div class="viewcode-block" id="SmoothModelRun.solve_single_value_old"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.solve_single_value_old">[docs]</a>    <span class="k">def</span> <span class="nf">solve_single_value_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternative_start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve the model and return a function of time.</span>

<span class="sd">        Args:</span>
<span class="sd">            alternative_start_values (numpy.array, optional): If not given, the </span>
<span class="sd">                original ``start_values`` are used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``f``: ``f(t)`` is a numpy.array that containts the </span>
<span class="sd">            pool contents at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system_single_value_old</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">alternative_start_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.solve_func"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.solve_func">[docs]</a>    <span class="k">def</span> <span class="nf">solve_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternative_start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve the model and return a function of time.</span>

<span class="sd">        Args:</span>
<span class="sd">            alternative_start_values (numpy.array, optional): If not given, the </span>
<span class="sd">                original ``start_values`` are used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``f``: ``f(t)`` is a numpy.array that containts the </span>
<span class="sd">            pool contents at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system_func</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>				 
                <span class="kc">None</span><span class="p">,</span> 
                <span class="n">alternative_start_values</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.solve_old"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.solve_old">[docs]</a>    <span class="k">def</span> <span class="nf">solve_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternative_times</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">alternative_start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve the model and return a solution grid.</span>

<span class="sd">        Args:</span>
<span class="sd">            alternative_times (numpy.array): If not given, the original time </span>
<span class="sd">                grid is used.</span>
<span class="sd">            alternative_start_values (numpy.array): If not given, </span>
<span class="sd">                the original start_values are used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools, contains the pool contents </span>
<span class="sd">            at the times given in the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system_old</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">alternative_times</span><span class="p">,</span> 
                        <span class="n">alternative_start_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.solve"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternative_start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve the model and return a solution grid. If the solution has been computed previously (even by other methods) the cached result will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            alternative_start_values (numpy.array): If not given, </span>
<span class="sd">                the original start_values are used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools, contains the pool contents </span>
<span class="sd">            at the times given in the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">soln</span><span class="p">,</span> <span class="n">sol_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span> 
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">alternative_start_values</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">soln</span></div>

    <span class="c1">##### fluxes as functions #####</span>
    
<div class="viewcode-block" id="SmoothModelRun.sol_funcs_old"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.sol_funcs_old">[docs]</a>    <span class="k">def</span> <span class="nf">sol_funcs_old</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return linearly interpolated solution functions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``f``: ``f(t)`` returns a numpy.array containing the</span>
<span class="sd">            pool contents at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="n">sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_old</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="n">sol_funcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">):</span>
            <span class="n">sol_inter</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">sol</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
            <span class="n">sol_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol_inter</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sol_funcs</span></div>

    <span class="c1">#fixme: test</span>
<div class="viewcode-block" id="SmoothModelRun.sol_funcs"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.sol_funcs">[docs]</a>    <span class="k">def</span> <span class="nf">sol_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="c1">#-&gt;List[Callable[float,float]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns list of linearly interpolated solution functions per pool.</span>
<span class="sd">        Returns:</span>
<span class="sd">            List of Python functions ``[f[i]]``, where ``f[i](t)`` returns </span>
<span class="sd">                pool i&#39;s content at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vec_sol_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="c1"># the factory is necessary to avoid unstrict evaluation</span>
        <span class="k">def</span> <span class="nf">func_maker</span><span class="p">(</span><span class="n">pool</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">vec_sol_func</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="n">pool</span><span class="p">]</span>
            <span class="k">return</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
       
        <span class="k">return</span> <span class="p">[</span><span class="n">func_maker</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">)]</span></div>

<div class="viewcode-block" id="SmoothModelRun.sol_funcs_dict_by_symbol"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.sol_funcs_dict_by_symbol">[docs]</a>    <span class="k">def</span> <span class="nf">sol_funcs_dict_by_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return linearly interpolated solution functions as a dictionary </span>
<span class="sd">        indexed by the symbols of the state variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#sol_funcs=self.sol_funcs()</span>
        <span class="n">sol_funcs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sol_funcs</span><span class="p">()</span>
        <span class="n">state_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_vector</span>
        <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">state_vector</span><span class="p">)</span>
        <span class="n">sol_dict_by_smybol</span><span class="o">=</span><span class="p">{</span><span class="n">state_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">sol_funcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">sol_dict_by_smybol</span></div>

<div class="viewcode-block" id="SmoothModelRun.sol_funcs_dict_by_name"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.sol_funcs_dict_by_name">[docs]</a>    <span class="k">def</span> <span class="nf">sol_funcs_dict_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return linearly interpolated solution functions. as a dictionary indexed by the name (string) of the</span>
<span class="sd">        state variables&quot;&quot;&quot;</span>
        <span class="n">sol_dict_by_name</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol_funcs_dict_by_symbol</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">sol_dict_by_name</span></div>
        
<div class="viewcode-block" id="SmoothModelRun.external_input_flux_funcs"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.external_input_flux_funcs">[docs]</a>    <span class="k">def</span> <span class="nf">external_input_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of the external input fluxes.</span>
<span class="sd">        The resulting functions base on sol_funcs and are linear interpolations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: ``{key: func}`` with ``key`` representing the pool which </span>
<span class="sd">            receives the input and ``func`` a function of time that returns </span>
<span class="sd">            a ``float``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">input_fluxes</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.internal_flux_funcs"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.internal_flux_funcs">[docs]</a>    <span class="k">def</span> <span class="nf">internal_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of the internal fluxes.</span>
<span class="sd">        </span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: ``{key: func}`` with ``key=(pool_from, pool_to)`` representing</span>
<span class="sd">            the pools involved and ``func`` a function of time that returns </span>
<span class="sd">            a ``float``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">internal_fluxes</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.external_output_flux_funcs"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.external_output_flux_funcs">[docs]</a>    <span class="k">def</span> <span class="nf">external_output_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of the external output fluxes.</span>
<span class="sd">        </span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: ``{key: func}`` with ``key`` representing the pool from which</span>
<span class="sd">            the output comes and ``func`` a function of time that returns a </span>
<span class="sd">            ``float``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">output_fluxes</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SmoothModelRun.acc_gross_external_output_vector"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.acc_gross_external_output_vector">[docs]</a>    <span class="k">def</span> <span class="nf">acc_gross_external_output_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the vectors of accumulated external outputs.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times)-1 x nr_pools</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="k">if</span> <span class="n">data_times</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data_times</span>
        <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">pool_nr</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_output_flux_funcs</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">pool_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">times</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">times</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">res</span></div>


    <span class="c1">#fixme: here _func indicated that this here is already a function of t</span>
    <span class="c1"># on other occasions _func indicated that a function is returned</span>
<div class="viewcode-block" id="SmoothModelRun.output_vector_func"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.output_vector_func">[docs]</a>    <span class="k">def</span> <span class="nf">output_vector_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a vector of the external output fluxes at time ``t``.</span>
<span class="sd">        </span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The ``i`` th entry is the output from pool ``i`` at </span>
<span class="sd">            time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_output_flux_funcs</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


    <span class="c1">##### fluxes as vector-valued functions #####</span>
    

    <span class="c1"># Note: This function could be rewritten using a vector valued input function </span>
<div class="viewcode-block" id="SmoothModelRun.external_input_vector_func"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.external_input_vector_func">[docs]</a>    <span class="k">def</span> <span class="nf">external_input_vector_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut_off</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a vector valued function for the external inputs.</span>


<span class="sd">        Returns:</span>
<span class="sd">            Python function ``u``: ``u(t)`` is a ``numpy.array`` containing the </span>
<span class="sd">            external inputs at time ``t``.</span>
<span class="sd">            Note: </span>
<span class="sd">            If the required (future) values for the input exceed the maximum of</span>
<span class="sd">            times they are assumed to be zero if ``cut_off`` is ``True``.  </span>
<span class="sd">            If ``cut_off`` is ``False`` then the input function is assumed to</span>
<span class="sd">            be valid everywhere which might be dangerous if they are</span>
<span class="sd">            extrapolated from data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_external_input_vector_func&#39;</span><span class="p">):</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># cut off inputs until t0 (exclusive)</span>
            <span class="k">if</span> <span class="n">cut_off</span><span class="p">:</span>
                <span class="n">t_valid</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="p">((</span><span class="n">t0</span><span class="o">&lt;=</span><span class="n">t</span><span class="p">)</span> <span class="ow">and</span> 
                                <span class="p">(</span><span class="n">t</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="k">else</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t_valid</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="kc">True</span>

            <span class="n">input_fluxes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_flux_funcs</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">input_fluxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">external_input_flux_funcs</span><span class="p">()[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">input_fluxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        
            <span class="n">u</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">input_fluxes</span><span class="p">],</span> 
                            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> 
                                <span class="k">if</span> <span class="n">t_valid</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,)))</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_external_input_vector_func</span> <span class="o">=</span> <span class="n">u</span>
     
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_external_input_vector_func</span></div>

 
<div class="viewcode-block" id="SmoothModelRun.output_rate_vector_at_t"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.output_rate_vector_at_t">[docs]</a>    <span class="k">def</span> <span class="nf">output_rate_vector_at_t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a vector of output rates at time ``t``.</span>

<span class="sd">        Args:</span>
<span class="sd">            t (float): The time at which the output rates are computed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The ith entry contains the output rate of pool ``i`` </span>
<span class="sd">            at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>

        <span class="c1">#sol_funcs = self.sol_funcs()</span>
        <span class="n">vec_sol_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="n">output_vec_at_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vector_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="c1">#        rate_vec = np.zeros((n,))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">vec_sol_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#        for pool in range(n):</span>
<span class="c1">#            #x = sol_funcs[pool](t)</span>
<span class="c1">#            if x != 0:</span>
<span class="c1">#                rate_vec[pool] = output_vec_at_t[pool] / x</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">output_vec_at_t</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span></div>


    <span class="c1">##### fluxes as vector over self.times #####</span>

<div class="viewcode-block" id="SmoothModelRun.acc_gross_external_input_vector"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.acc_gross_external_input_vector">[docs]</a>    <span class="k">def</span> <span class="nf">acc_gross_external_input_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid of accumulated external input vectors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="k">if</span> <span class="n">data_times</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data_times</span>
        <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">pool_nr</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_flux_funcs</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">pool_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">times</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">times</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">res</span></div>
    

    <span class="nd">@property</span>
    <span class="c1">#this function should be rewritten using the vector values solution </span>
    <span class="k">def</span> <span class="nf">external_input_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid of external input vectors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">external_inputs</span><span class="p">)</span>
        <span class="c1"># no inputs at t0 (only &gt;t0)</span>
        <span class="c1">#res[0,:] = np.zeros((self.nr_pools,))</span>
        
        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@property</span>
    <span class="c1">#this function should be rewritten using the vector valued solution </span>
    <span class="k">def</span> <span class="nf">external_output_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid of external output vectors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">external_outputs</span><span class="p">))</span>

    <span class="nd">@property</span>    
    <span class="k">def</span> <span class="nf">output_rate_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid of output rate vectors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools, ``solution/output_vector``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">output_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_output_vector</span>

        <span class="c1"># take care of possible division by zero</span>
        <span class="n">output_vec</span><span class="p">[</span><span class="n">soln</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">soln</span><span class="p">[</span><span class="n">soln</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">output_vec</span><span class="o">/</span><span class="n">soln</span>

    <span class="c1">#fixme hm: test</span>
<div class="viewcode-block" id="SmoothModelRun.acc_gross_internal_flux_matrix"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.acc_gross_internal_flux_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">acc_gross_internal_flux_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid of flux matrices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools x nr_pools</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="k">if</span> <span class="n">data_times</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data_times</span>
        <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_flux_funcs</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">key</span>
                <span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">times</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">times</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">res</span></div>


    <span class="c1">##### age density methods #####</span>
    

<div class="viewcode-block" id="SmoothModelRun.pool_age_densities_single_value"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.pool_age_densities_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">pool_age_densities_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function for the pool age densities.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a numpy.array containing the masses with the given </span>
<span class="sd">                age at time :math:`t_0`. Defaults to None, meaning that all </span>
<span class="sd">                initial mass is considered to have zero age.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``p_sv``: ``p_sv(a, t)`` returns ``a numpy.array`` </span>
<span class="sd">            containing the pool contents with age ``a`` at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p1_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_1_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">p2_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_2_single_value</span><span class="p">()</span>

        <span class="n">p_sv</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">p1_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">p2_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">p_sv</span></div>

    
    <span class="c1"># returns a function p that takes an age array &quot;ages&quot; as argument</span>
    <span class="c1"># and gives back a three-dimensional ndarray (ages x times x pools)</span>
    <span class="c1"># start_age_densities is a array-valued function of age</span>
<div class="viewcode-block" id="SmoothModelRun.pool_age_densities_func"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.pool_age_densities_func">[docs]</a>    <span class="k">def</span> <span class="nf">pool_age_densities_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function that takes an array of ages and returns the </span>
<span class="sd">        pool age densities.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a numpy.array containing the masses with the given </span>
<span class="sd">                age at time :math:`t_0` for every pool. </span>
<span class="sd">                Defaults to None, meaning that all initial mass is considered </span>
<span class="sd">                to have zero age.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Python function ``p``: ``p(ages)`` returns a ``numpy.ndarray`` </span>
<span class="sd">            len(ages) x len(times) x nr_pools containing the pool contents </span>
<span class="sd">            with the respective ages at the respective times, where ``ages`` </span>
<span class="sd">            is a ``numpy.array``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_1</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_2</span><span class="p">()</span>
        
        <span class="k">def</span> <span class="nf">p</span><span class="p">(</span><span class="n">ages</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_computed_age_density_fields&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ages</span><span class="p">))</span> <span class="ow">in</span> 
                        <span class="bp">self</span><span class="o">.</span><span class="n">_computed_age_density_fields</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="c1">#print(&#39;using cached result&#39;)</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_computed_age_density_fields</span><span class="p">[</span>
                                <span class="p">(</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ages</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_computed_age_density_fields</span> <span class="o">=</span> <span class="p">{}</span>
        
            <span class="n">field_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">ages</span><span class="p">):</span>
                <span class="n">field_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p1</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">]))</span> <span class="o">+</span> <span class="n">p2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">])))</span>

            <span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">field_list</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">,:,:]</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_computed_age_density_fields</span><span class="p">[</span>
                <span class="p">(</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ages</span><span class="p">))]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="n">field</span>
                
        <span class="k">return</span> <span class="n">p</span></div>

    
<div class="viewcode-block" id="SmoothModelRun.system_age_density_single_value"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.system_age_density_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">system_age_density_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function for the system age density.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a numpy.array containing the masses with the given </span>
<span class="sd">                age at time :math:`t_0`. </span>
<span class="sd">                Defaults to None, meaning that all initial mass is considered </span>
<span class="sd">                to have zero age.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``sys_p_sv``: ``sys_p_sv(a, t)`` returns the system </span>
<span class="sd">            content with age ``a`` at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_age_densities_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">sys_p_sv</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">sys_p_sv</span></div>


    <span class="c1"># return array ages x times with ages based on pool_age_densities</span>
<div class="viewcode-block" id="SmoothModelRun.system_age_density"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.system_age_density">[docs]</a>    <span class="k">def</span> <span class="nf">system_age_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool_age_densities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the system age density based on the given pool age densities.</span>

<span class="sd">        Args:</span>
<span class="sd">            pool_age_densites (numpy.ndarray len(ages) x len(times) x nr_pools):</span>
<span class="sd">                The pool age density values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: (len(ages) x len(times)) The sum of the pool age </span>
<span class="sd">            contents over all pools.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pool_age_densities</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></div>


    <span class="c1"># combine pool and system age densities to one numpy array</span>
<div class="viewcode-block" id="SmoothModelRun.age_densities"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.age_densities">[docs]</a>    <span class="k">def</span> <span class="nf">age_densities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool_age_densities</span><span class="p">,</span> <span class="n">system_age_density</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine pool and system age densities to one numpy.array.</span>

<span class="sd">        Args:</span>
<span class="sd">            pool_age_densites (numpy.ndarray len(ages) x len(times) x nr_pools):</span>
<span class="sd">                The pool age density values.</span>
<span class="sd">            system_age_density (numpy.ndarray len(ages) x len(times)): </span>
<span class="sd">                The system age density values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: (len(ages) x len(times) x (nr_pools+1)).</span>
<span class="sd">            The system age density values are appended to the end of the </span>
<span class="sd">            pool density values (system = pool ``d+1`` with ``d = nr_pools``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">nr_ages</span> <span class="o">=</span> <span class="n">pool_age_densities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nr_times</span> <span class="o">=</span> <span class="n">pool_age_densities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">_age_densities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nr_ages</span><span class="p">,</span> <span class="n">nr_times</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">_age_densities</span><span class="p">[:,:,:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool_age_densities</span>
        <span class="n">_age_densities</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">system_age_density</span>

        <span class="k">return</span> <span class="n">_age_densities</span></div>


    <span class="c1">##### age moment methods #####</span>


<div class="viewcode-block" id="SmoothModelRun.age_moment_vector_from_densities"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.age_moment_vector_from_densities">[docs]</a>    <span class="k">def</span> <span class="nf">age_moment_vector_from_densities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th moment of the pool ages by integration.</span>

<span class="sd">        This function is extremely slow, since for each pool the integral over </span>
<span class="sd">        the density is computed based on the singe-valued functions. It is </span>
<span class="sd">        implemented only for the sake of completeness and to test the results </span>
<span class="sd">        obtained by faster methods.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the moment to be computed.</span>
<span class="sd">            start_age_densities (Python function, optional): </span>
<span class="sd">                A function of age that returns a numpy.array containing the </span>
<span class="sd">                masses with the given age at time :math:`t_0`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools. </span>
<span class="sd">            Contains the ``order`` th moment </span>
<span class="sd">            of the pool ages over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_age_densities_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="c1">#x = self.solve_old()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">n</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">k</span>   <span class="o">=</span> <span class="n">order</span>

        <span class="k">def</span> <span class="nf">am_at_time_index_for_pool</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">integrand</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">])[</span><span class="n">pool</span><span class="p">]</span>
            
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>        

        <span class="k">def</span> <span class="nf">age_moment_at_time_index</span><span class="p">(</span><span class="n">ti</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">am_at_time_index_for_pool</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span> 
                                <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>

        <span class="n">am_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">age_moment_at_time_index</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> 
                            <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))])</span> 
        <span class="n">am</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">am_arr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">am</span></div>


<div class="viewcode-block" id="SmoothModelRun.age_moment_vector_semi_explicit"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.age_moment_vector_semi_explicit">[docs]</a>    <span class="k">def</span> <span class="nf">age_moment_vector_semi_explicit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> 
                                        <span class="n">start_age_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th moment of the pool ages by a semi-explicit </span>
<span class="sd">        formula.</span>

<span class="sd">        This function bases on a semi-explicit formula such that no improper </span>
<span class="sd">        integrals need to be computed.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the age moment to be computed.</span>
<span class="sd">            start_age_moments (numpy.ndarray order x nr_pools, optional): </span>
<span class="sd">                Given initial age moments up to the order of interest. </span>
<span class="sd">                Can possibly be computed by :func:`moments_from_densities`. </span>
<span class="sd">                Defaults to ``None`` assuming zero initial ages.</span>
<span class="sd">            times (numpy.array, optional): Time grid. </span>
<span class="sd">                Defaults to ``None`` and the original time grid is used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools.</span>
<span class="sd">            The ``order`` th pool age moments over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
            
        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">order</span>
        
        <span class="k">if</span> <span class="n">start_age_moments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_age_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">order</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="n">start_age_moments</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">start_age_moments</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">p2_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_2_single_value</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span> 
                                    <span class="k">else</span> <span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">Phi</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">x0_a0_bar</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span>
                
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">)</span> <span class="o">*</span> <span class="n">start_age_moments</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>

        <span class="k">def</span> <span class="nf">both_parts_at_time</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">part2_time</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">def</span> <span class="nf">part2_time_index_pool</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">**</span><span class="n">k</span> <span class="o">*</span> <span class="n">p2_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">part2_time_index_pool</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span> 
                                    <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>

            <span class="k">def</span> <span class="nf">part1_time</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">def</span> <span class="nf">summand</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">binomial</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">x0_a0_bar</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>

                <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">summand</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>

            <span class="k">return</span> <span class="n">part1_time</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">part2_time</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="c1">#soln = self.solve_old()</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">both_parts_normalized_at_time_index</span><span class="p">(</span><span class="n">ti</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">both_parts_at_time</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">diag_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]])</span>
            <span class="n">X_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diag_values</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1">#return (np.mat(X_inv) * np.mat(bp).transpose()).A1</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">X_inv</span><span class="p">,</span> <span class="n">bp</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">both_parts_normalized_at_time_index</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> 
                            <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))])</span></div>
        

<div class="viewcode-block" id="SmoothModelRun.age_moment_vector"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.age_moment_vector">[docs]</a>    <span class="k">def</span> <span class="nf">age_moment_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th pool age moment vector over the time grid </span>
<span class="sd">        by an ODE system.</span>

<span class="sd">        This function solves an ODE system to obtain the pool age moments very</span>
<span class="sd">        fast. If the system has empty pools at the beginning, the semi-explicit </span>
<span class="sd">        formula is used until all pools are non-empty. Then the ODE system </span>
<span class="sd">        starts.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the pool age moments to be computed.</span>
<span class="sd">            start_age_moments (numpy.ndarray order x nr_pools, optional): </span>
<span class="sd">                Given initial age moments up to the order of interest. </span>
<span class="sd">                Can possibly be computed by :func:`moments_from_densities`. </span>
<span class="sd">                Defaults to None assuming zero initial ages.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x nr_pools.</span>
<span class="sd">            The ``order`` th pool age moments over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        
        <span class="k">if</span> <span class="n">start_age_moments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_age_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">order</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        
        <span class="n">max_order</span><span class="o">=</span><span class="n">start_age_moments</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">order</span><span class="o">&gt;</span><span class="n">max_order</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                To solve the moment system with order</span><span class="si">{0}</span><span class="s2"></span>
<span class="s2">                start_age_moments up to (at least) the same order have to be</span>
<span class="s2">                provided. But the start_age_moments.shape was</span>
<span class="s2">                </span><span class="si">{1}</span><span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="n">start_age_moments</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">order</span><span class="o">&lt;</span><span class="n">max_order</span><span class="p">:</span>
            <span class="n">warning</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                Start_age_moments contained higher order values than needed.</span>
<span class="s2">                start_age_moments order was </span><span class="si">{0}</span><span class="s2"> while the requested order was</span>
<span class="s2">                </span><span class="si">{1}</span><span class="s2">. This is no problem but possibly unintended. The higer</span>
<span class="s2">                order moments will be clipped &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_order</span><span class="p">,</span><span class="n">order</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># make sure that the start age moments are clipped to the order</span>
            <span class="c1"># (We do not need start values for higher moments and the clipping</span>
            <span class="c1"># avoids problems with recasting if higher order moments are given </span>
            <span class="c1"># by the user)</span>
            <span class="n">start_age_moments</span><span class="o">=</span><span class="n">start_age_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">,:]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">):</span>
            <span class="c1">#ams = self._solve_age_moment_system_old(order, start_age_moments)</span>
            <span class="n">ams</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ams</span><span class="p">[:,</span><span class="n">n</span><span class="o">*</span><span class="n">order</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># try to start adapted mean_age_system once no pool </span>
            <span class="c1"># has np.nan as mean_age (empty pool)</span>

            <span class="c1"># find last time index that contains an empty pool --&gt; ti</span>
            <span class="c1">#soln = self.solve_old()</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
            <span class="n">ti</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">content</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ti</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span> 
                <span class="n">ti</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">content</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span>

            <span class="c1"># not forever an empty pool there?</span>
            <span class="k">if</span> <span class="n">ti</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
                <span class="c1"># compute moment with semi-explicit formula </span>
                <span class="c1"># as long as there is an empty pool</span>
                <span class="n">amv1_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">amv1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ti</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">order</span><span class="o">*</span><span class="n">n</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">amv1_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">age_moment_vector_semi_explicit</span><span class="p">(</span>
                        <span class="n">k</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">,</span> <span class="n">times</span><span class="p">[:</span><span class="n">ti</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">amv1</span><span class="p">[:,(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">:</span><span class="n">k</span><span class="o">*</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">amv1_k</span>

                <span class="c1"># use last values as start values for moment system </span>
                <span class="c1"># with nonzero start values</span>
                <span class="n">new_start_age_moments</span> <span class="o">=</span> <span class="n">amv1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
                <span class="n">start_values</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#ams = self._solve_age_moment_system_old(</span>
                <span class="c1">#    order, new_start_age_moments, times[ti+1:], start_values)</span>
                <span class="n">ams</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system</span><span class="p">(</span>
                    <span class="n">order</span><span class="p">,</span> <span class="n">new_start_age_moments</span><span class="p">,</span> <span class="n">start_values</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">amv2</span> <span class="o">=</span> <span class="n">ams</span><span class="p">[:,</span><span class="n">n</span><span class="o">*</span><span class="n">order</span><span class="p">:]</span>

                <span class="c1"># put the two parts together</span>
                <span class="n">part1</span> <span class="o">=</span> <span class="n">amv1</span><span class="p">[:,(</span><span class="n">order</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">:</span><span class="n">order</span><span class="o">*</span><span class="n">n</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">amv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>
                <span class="n">amv</span><span class="p">[:</span><span class="n">part1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="n">part1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">part1</span>
                <span class="n">amv</span><span class="p">[</span><span class="n">part1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="p">:</span><span class="n">amv2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">amv2</span>
                <span class="k">return</span> <span class="n">amv</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># always an empty pool there</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">age_moment_vector_semi_explicit</span><span class="p">(</span>
                        <span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span></div>


    <span class="c1"># requires start moments &lt;= order</span>
<div class="viewcode-block" id="SmoothModelRun.system_age_moment"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.system_age_moment">[docs]</a>    <span class="k">def</span> <span class="nf">system_age_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th system age moment vector over the time grid </span>
<span class="sd">        by an ODE system.</span>

<span class="sd">        The pool age moments are computed by :func:`age_moment_vector` and then </span>
<span class="sd">        weighted corresponding to the pool contents.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the pool age moments to be computed.</span>
<span class="sd">            start_age_moments (numpy.ndarray order x nr_pools, optional): </span>
<span class="sd">                Given initial age moments up to the order of interest. </span>
<span class="sd">                Can possibly be computed by :func:`moments_from_densities`. </span>
<span class="sd">                Defaults to None assuming zero initial ages.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The ``order`` th system age moment over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">age_moment_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">age_moment_vector</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>
        <span class="n">age_moment_vector</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">age_moment_vector</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1">#soln = self.solve_old()</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
         
        <span class="n">total_mass</span> <span class="o">=</span> <span class="n">soln</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># row sum</span>
        <span class="n">total_mass</span><span class="p">[</span><span class="n">total_mass</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">system_age_moment</span> <span class="o">=</span> <span class="p">(</span><span class="n">age_moment_vector</span><span class="o">*</span><span class="n">soln</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">total_mass</span>

        <span class="k">return</span> <span class="n">system_age_moment</span></div>
        

    <span class="c1">##### transit time density methods #####</span>


<div class="viewcode-block" id="SmoothModelRun.backward_transit_time_density_single_value_func"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.backward_transit_time_density_single_value_func">[docs]</a>    <span class="k">def</span> <span class="nf">backward_transit_time_density_single_value_func</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">start_age_densities</span>
        <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function that returns a single value for the </span>
<span class="sd">        backward transit time density.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): </span>
<span class="sd">                A function of age that returns a numpy.array containing the </span>
<span class="sd">                masses with the given age at time :math:`t_0`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``p_sv``: ``p_sv(a, t)`` returns the mass that </span>
<span class="sd">            leaves the system at time ``t`` with age ``a``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">p_age_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_age_densities_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">p_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p_age_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_rate_vector_at_t</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> 
            
        <span class="k">return</span> <span class="n">p_sv</span></div>


    <span class="c1"># return an array ages x times with ages based on pool_age_densities</span>
<div class="viewcode-block" id="SmoothModelRun.backward_transit_time_density"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.backward_transit_time_density">[docs]</a>    <span class="k">def</span> <span class="nf">backward_transit_time_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool_age_densities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the backward transit time based on given pool age densities.</span>

<span class="sd">        The result is obtained by computing a weighted sum of the pool age </span>
<span class="sd">        densities according to output rates.</span>

<span class="sd">        Args:</span>
<span class="sd">            pool_age_densites (numpy.ndarray len(ages) x len(times) x nr_pools):</span>
<span class="sd">                The pool age density values.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(ages) x len(times). Mass leaving the system with </span>
<span class="sd">            the respective age at the respective time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_rate_vector</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pool_age_densities</span><span class="o">*</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="SmoothModelRun.forward_transit_time_density_single_value_func"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.forward_transit_time_density_single_value_func">[docs]</a>    <span class="k">def</span> <span class="nf">forward_transit_time_density_single_value_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut_off</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">my_B_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function that returns a single value for the </span>
<span class="sd">        forward transit time density.</span>

<span class="sd">        Args:</span>
<span class="sd">            cut_off (bool, optional): If ``True``, no density values are going to </span>
<span class="sd">                be computed after the end of the time grid, instead </span>
<span class="sd">                ``numpy.nan`` will be returned. </span>
<span class="sd">                Defaults to ``True`` and ``False`` might lead to unexpected behavior.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Python function ``p_sv``: ``p_sv(a, t)`` returns how much mass will </span>
<span class="sd">            leave the system with age ``a`` when it came in at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">my_B_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">my_B_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_solve_func_skew</span><span class="p">())</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="n">input_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   
        <span class="n">t_max</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
        <span class="k">def</span> <span class="nf">p_ftt_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="c1"># nothing leaves before t0</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">t0</span><span class="p">):</span> <span class="k">return</span> <span class="mf">0.0</span>

            <span class="c1">#fixme: for Metropolis-Hastings we might need the density </span>
            <span class="c1">#very far away...</span>
            <span class="c1"># we cannot compute the density if t+a is out of bounds</span>
            <span class="k">if</span> <span class="n">cut_off</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">t_max</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">u</span> <span class="o">=</span> <span class="n">input_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="mf">0.0</span>
            
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">my_B_func</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">),</span><span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">p_ftt_sv</span></div>


    <span class="c1">#fixme: return value not consistent with backward_transit_time_density</span>
    <span class="c1"># not that easy to resolve, since here we do not use age_densities,</span>
    <span class="c1"># instead ages is really needed to be able to make the shift or call </span>
    <span class="c1"># the state_transition_operator</span>
<div class="viewcode-block" id="SmoothModelRun.forward_transit_time_density_func"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.forward_transit_time_density_func">[docs]</a>    <span class="k">def</span> <span class="nf">forward_transit_time_density_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut_off</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function based on an age array for the forward transit time </span>
<span class="sd">        density.</span>

<span class="sd">        Args:</span>
<span class="sd">            cut_off (bool, optional): If True, no density values are going to </span>
<span class="sd">                be computed after the end of the time grid, instead </span>
<span class="sd">                ``numpy.nan`` will be returned. </span>
<span class="sd">                Defaults to True and False might lead to unexpected behavior.</span>
<span class="sd">            times (numpy.array, optional): Time grid. </span>
<span class="sd">                Defaults to ``None`` and the original time grid is used.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Python function ``p``: ``p(ages)`` is a ``numpy.ndarray`` </span>
<span class="sd">            len(ages) x len(times) that gives the mass that will leave the</span>
<span class="sd">            system with the respective age when it came in at time ``t``, </span>
<span class="sd">            where ``ages`` is a ``numpy.array``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wrapper</span> <span class="o">=</span> <span class="n">custom_lru_cache_wrapper</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">))</span>
        <span class="n">cached_B_func</span> <span class="o">=</span> <span class="n">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_solve_func_skew</span><span class="p">()))</span>

        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="n">p_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_transit_time_density_single_value_func</span><span class="p">(</span>
            <span class="n">cut_off</span><span class="p">,</span> 
            <span class="n">my_B_func</span><span class="o">=</span><span class="n">cached_B_func</span>
        <span class="p">)</span>

        <span class="n">pp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="c1">#p = lambda ages: np.array([pp(a) for a in ages], np.float)</span>
        <span class="k">def</span> <span class="nf">p</span><span class="p">(</span><span class="n">ages</span><span class="p">):</span>
            <span class="n">field_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">ages</span><span class="p">):</span>
                <span class="n">field_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

            <span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">field_list</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">field</span>

        <span class="k">return</span> <span class="n">p</span></div>


    <span class="c1">##### transit time moment methods #####</span>

    
<div class="viewcode-block" id="SmoothModelRun.backward_transit_time_moment_from_density"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.backward_transit_time_moment_from_density">[docs]</a>    <span class="k">def</span> <span class="nf">backward_transit_time_moment_from_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">order</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th backward transit time moment based on an </span>
<span class="sd">        improper integral over the density.</span>

<span class="sd">        This function is extremely slow and implemented only for the sake of </span>
<span class="sd">        completeness and for testing results from faster approaches.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the backward transit time moment that is </span>
<span class="sd">                to be computed.</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a numpy.array containing the masses with the given </span>
<span class="sd">                age at time :math:`t_0`.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The ``order`` th backward transit time moment over the </span>
<span class="sd">            time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backward_transit_time_density_single_value_func</span><span class="p">(</span>
                    <span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">order</span>

        <span class="n">ext_outp_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_output_vector</span>
        <span class="n">ext_outp</span> <span class="o">=</span> <span class="n">ext_outp_vec</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     
        <span class="k">def</span> <span class="nf">btt_moment_at_time_index</span><span class="p">(</span><span class="n">ti</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">integrand</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">])</span>
            
            <span class="k">return</span> <span class="n">ext_outp</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>        

        <span class="n">bttm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">btt_moment_at_time_index</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> 
                            <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))])</span> 
        <span class="k">return</span> <span class="n">bttm</span></div>


<div class="viewcode-block" id="SmoothModelRun.backward_transit_time_moment"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.backward_transit_time_moment">[docs]</a>    <span class="k">def</span> <span class="nf">backward_transit_time_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the ``order`` th backward transit time moment based on the </span>
<span class="sd">        :func:`age_moment_vector`.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (int): The order of the backward transit time moment that is </span>
<span class="sd">                to be computed.</span>
<span class="sd">            start_age_moments (numpy.ndarray order x nr_pools, optional): </span>
<span class="sd">                Given initial age moments up to the order of interest. </span>
<span class="sd">                Can possibly be computed by :func:`moments_from_densities`. </span>
<span class="sd">                Defaults to None assuming zero initial ages.</span>
<span class="sd">       </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The ``order`` th backward transit time moment over the </span>
<span class="sd">            time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="n">age_moment_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">age_moment_vector</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_output_vector</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">age_moment_vector</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">r</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>


<span class="c1">#    def forward_transit_time_moment(self, order, epsrel=1e-2):</span>
<span class="c1">#        &quot;&quot;&quot;Compute the ``order`` th forward transit time moment.</span>
<span class="c1">#</span>
<span class="c1">#        Attention! This function integrates over the state transition operator </span>
<span class="c1">#        until infinite time.</span>
<span class="c1">#        The results are going to be weird, since at the end of the time grid </span>
<span class="c1">#        some cut- off will happen which biases the result.</span>
<span class="c1">#        Be also aware that additionally - to avoid convergence issues in quad -</span>
<span class="c1">#        the relative tolerance is set to 1e-2 by default.</span>
<span class="c1">#</span>
<span class="c1">#        Args:</span>
<span class="c1">#            order (int): The order of the forward transit time moment to be </span>
<span class="c1">#                computed.</span>
<span class="c1">#</span>
<span class="c1">#        Returns:</span>
<span class="c1">#            numpy.array: The ``order`` th forward transit time moment over the </span>
<span class="c1">#            time grid.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        k = order</span>
<span class="c1">#        times = self.times</span>
<span class="c1">#        Phi = self._state_transition_operator</span>
<span class="c1">#        input_vector = self.external_input_vector</span>
<span class="c1">#</span>
<span class="c1">#        #import warnings</span>
<span class="c1">#        #from scipy.integrate import IntegrationWarning</span>
<span class="c1">#        #warnings.simplefilter(&quot;error&quot;, IntegrationWarning)</span>
<span class="c1">#        def moment_at_ti(ti):</span>
<span class="c1">#            u = input_vector[ti] </span>
<span class="c1">#            </span>
<span class="c1">#            # if we have no inputs, there cannot be a transit(time)</span>
<span class="c1">#            if u.sum() == 0:    </span>
<span class="c1">#                return np.nan</span>
<span class="c1">#</span>
<span class="c1">#            def integrand(a):</span>
<span class="c1">#                res = (k*a**(k-1)*Phi(times[ti]+a, times[ti], u).sum())/u.sum()</span>
<span class="c1">#                #print(a, Phi(times[ti]+a, times[ti], u), res)</span>
<span class="c1">#                return res</span>
<span class="c1">#            </span>
<span class="c1">#            return quad(integrand, 0, np.infty,epsrel=epsrel)[0]</span>
<span class="c1">#            </span>
<span class="c1">#            # Remark: </span>
<span class="c1">#            # We want to compute an inproper integral </span>
<span class="c1">#            # instead of calling res=quad(integrand, 0, np.infty)[0]</span>
<span class="c1">#            # we could apply a variable transformation z=a/(c+a) # with an arbitrary c (possibly c=1 but we can optimize the choice  for better performance) </span>
<span class="c1">#            # so we have \int_0^\infty f(a) dx= \int_0^z(a=\infty) f(a(z))*da/dz *dz  =\int_0^1  f(a(z)) c/(1-z**2) dz</span>
<span class="c1">#            # to do:</span>
<span class="c1">#            # To have the best accuracy we try to find c so that the peak of the integrand is projected to the middle of the new integration interval [0,1]</span>
<span class="c1">#            # 1.) find the maximum of the integrand</span>
<span class="c1">#            # 2.) find the c that projects this x to z=1/2</span>
<span class="c1">#            #c =1000</span>
<span class="c1">#            #def a(z):</span>
<span class="c1">#            #    return c*z/(1-z) </span>
<span class="c1">#            #def transformed_integrand(z):</span>
<span class="c1">#            #    res = integrand(a(z))*c/(1-z**2) </span>
<span class="c1">#            #    return res</span>
<span class="c1">#            #</span>
<span class="c1">#            #return quad(transformed_integrand, 0, 1)[0]</span>
<span class="c1">#</span>
<span class="c1">#        #res = np.array([moment_at_ti(ti) for ti in range(len(times))])</span>
<span class="c1">#        res = []</span>
<span class="c1">#        for ti in tqdm(range(len(times))):</span>
<span class="c1">#            res.append(moment_at_ti(ti))</span>
<span class="c1">#        res = np.array(res)</span>
<span class="c1">#</span>
<span class="c1">#        return res</span>


    <span class="c1">#fixme: split into two functions for SCCS and MH</span>
    <span class="c1"># do not use dict as default value</span>
<div class="viewcode-block" id="SmoothModelRun.apply_to_forward_transit_time_simulation"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.apply_to_forward_transit_time_simulation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_to_forward_transit_time_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">f_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">},</span> <span class="n">N</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">MH</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is just a tentative approach.</span>

<span class="sd">        To be honest, the problem of an unkown infinite future cannot be solved </span>
<span class="sd">        this way, since the densities used to simulate forward transit time </span>
<span class="sd">        random variables are biased by the cut-off at the end of the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># f is a Python function, for the mean, take f = np.mean</span>
        <span class="c1"># N is the number of simulations per each time step</span>
        <span class="c1"># M is the number of collocation points for </span>
        <span class="c1"># stochastic collocation sampling</span>
        <span class="c1"># allowed values for M are 2, 3, 4, ..., 11</span>
        <span class="c1"># other values lead to inverse transform sampling (slow)</span>
        <span class="c1"># k is the order of the smoothing and interpolating spline</span>
        <span class="c1"># &#39;smoothing_spline&#39; is best used for inverse transform sampling, </span>
        <span class="c1"># because of additional smoothing for low</span>
        <span class="c1"># number of random variates</span>
        <span class="c1"># for SCMCS (M in [2,...,11]), &#39;interpolation&#39; is better, </span>
        <span class="c1"># because the higher number of random variates </span>
        <span class="c1"># (because of faster sampling) makes their mean already quite precise </span>
        <span class="c1"># (in the framework of what is possible with SCMCS)</span>
  
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="n">input_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">MH</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">def</span> <span class="nf">F_FTT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">input_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="mf">0.0</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    
            
            <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">CDF</span><span class="p">):</span>
                <span class="c1"># compute lagrange polynomial p if M is in [2, ..., 11]</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">stochastic_collocation_transform</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">CDF</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
                    <span class="c1"># inverse transform sampling</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inverse transform sampling&#39;</span><span class="p">)</span>
                    <span class="n">rvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">draw_rv</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="p">)</span>
                    <span class="n">rvs</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">norms</span><span class="p">)</span>
        
                <span class="k">return</span> <span class="n">rvs</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">p_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_transit_time_density_single_value_func</span><span class="p">(</span>
                <span class="n">cut_off</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="k">def</span> <span class="nf">f_FTT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="n">p_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>


        <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">f_name</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;values&#39;</span><span class="p">:</span> <span class="p">[],</span> 
                        <span class="s1">&#39;smoothing_spline&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="s1">&#39;interpolation&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span> <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">f_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="c1"># no iput means no forward transit time</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">input_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="n">rvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">MH</span><span class="p">:</span>
                    <span class="n">rvs</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F_FTT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;calls of state transition operator&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rvs</span> <span class="o">=</span> <span class="n">MH_sampling</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">f_FTT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;calls of forward transit time density&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">f_name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">f_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">rvs</span><span class="p">)</span>
                <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;values&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                
        <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;values&#39;</span><span class="p">])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># give weight zero to nan values fo compting the spline</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">y</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;smoothing_spline&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span>
                <span class="n">times</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="o">=~</span><span class="n">w</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;interpolation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">~</span><span class="n">w</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="o">~</span><span class="n">w</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>

    <span class="c1"># use inverse transform sampling</span>
<div class="viewcode-block" id="SmoothModelRun.apply_to_forward_transit_time_simulation_its"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.apply_to_forward_transit_time_simulation_its">[docs]</a>    <span class="k">def</span> <span class="nf">apply_to_forward_transit_time_simulation_its</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">f_dict</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is just a tentative approach.</span>

<span class="sd">        To be honest, the problem of an unkown infinite future cannot be solved </span>
<span class="sd">        this way, since the densities used to simulate forward transit time </span>
<span class="sd">        random variables are biased by the cut-off at the end of the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># f is a Python function, for the mean, take f = np.mean</span>
        <span class="c1"># N is the number of simulations per each time step</span>
        <span class="c1"># times is an np.array of interpolation points</span>
        <span class="c1"># k is the order of the smoothing and interpolating spline</span>
        <span class="c1"># &#39;smoothing_spline&#39; is best used for inverse transform sampling, </span>
        <span class="c1"># because of additional smoothing for low</span>
        <span class="c1"># number of random variates</span>
  
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="n">input_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">F_FTT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">input_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="mf">0.0</span>

            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">f_name</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;values&#39;</span><span class="p">:</span> <span class="p">[],</span> 
                        <span class="s1">&#39;smoothing_spline&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="s1">&#39;interpolation&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span> <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">f_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="c1"># no iput means no forward transit time</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">input_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="n">rvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">CDF</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F_FTT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">rvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">draw_rv</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>

            <span class="k">for</span> <span class="n">f_name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">f_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">rvs</span><span class="p">)</span>
                <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;values&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                
        <span class="k">def</span> <span class="nf">compute_splines</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;values&#39;</span><span class="p">])</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># give weight zero to nan values fo compting the spline</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">y</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;smoothing_spline&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span>
                    <span class="n">times</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="o">=~</span><span class="n">w</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">res</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="s1">&#39;interpolation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">~</span><span class="n">w</span><span class="p">],</span><span class="n">z</span><span class="p">[</span><span class="o">~</span><span class="n">w</span><span class="p">],</span><span class="n">kind</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">compute_splines</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span></div>


    <span class="c1">##### comma separated values output methods #####</span>


<div class="viewcode-block" id="SmoothModelRun.save_pools_and_system_density_csv"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.save_pools_and_system_density_csv">[docs]</a>    <span class="k">def</span> <span class="nf">save_pools_and_system_density_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">pool_age_densities</span><span class="p">,</span> 
            <span class="n">system_age_density</span><span class="p">,</span> <span class="n">ages</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save the pool and system age densities to a csv file.</span>

<span class="sd">        The system value will be coded into pool number -1.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): The name of the csv file to be written.</span>
<span class="sd">            pool_age_densites (numpy.ndarray len(ages) x len(times) x nr_pools):</span>
<span class="sd">                The pool age density values.</span>
<span class="sd">            system_age_density (numpy.ndarray len(ages) x len(times)): </span>
<span class="sd">                The system age density values.</span>
<span class="sd">            ages (numpy.array): The ages that correspond to the indices in the</span>
<span class="sd">                zeroth dimension of the density arrays.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
    
        <span class="n">ndarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">system_age_density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ndarr</span><span class="p">[:,:,:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool_age_densities</span>
        <span class="n">ndarr</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">system_age_density</span>

        <span class="n">pool_entries</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">melt</span><span class="p">(</span><span class="n">ndarr</span><span class="p">,</span> <span class="p">[</span><span class="n">ages</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">pool_entries</span><span class="p">])</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&quot;age&quot;, &quot;time&quot;, &quot;pool&quot;, &quot;value&quot;&#39;</span>
        <span class="n">save_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">melted</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span></div>


<div class="viewcode-block" id="SmoothModelRun.save_pools_and_system_value_csv"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.save_pools_and_system_value_csv">[docs]</a>    <span class="k">def</span> <span class="nf">save_pools_and_system_value_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">pools_ndarr</span><span class="p">,</span> 
            <span class="n">system_arr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save pool and system values to a csv file.</span>

<span class="sd">        Values could be the mean age, for example. One dimension less than a</span>
<span class="sd">        density.</span>
<span class="sd">        The system value will be coded into pool number -1.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The name of the csv file to be written.</span>
<span class="sd">            pools_ndarr (numpy.ndarray len(times) x nr_pools): The values to be</span>
<span class="sd">                saved over the time-pool grid.</span>
<span class="sd">            system_arr (numpy.array): The values over the time grid </span>
<span class="sd">                corresponding to the system.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
    
        <span class="n">ndarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">pools_ndarr</span><span class="p">,</span> <span class="n">system_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="mi">1</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">pool_entries</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">melt</span><span class="p">(</span><span class="n">ndarr</span><span class="p">,</span> <span class="p">[</span><span class="n">times</span><span class="p">,</span> <span class="n">pool_entries</span><span class="p">])</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&quot;time&quot;, &quot;pool&quot;, &quot;value&quot;&#39;</span>
        <span class="n">save_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">melted</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span></div>


    <span class="c1">## helping methods ##</span>

<div class="viewcode-block" id="SmoothModelRun.density_values_for_pools"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.density_values_for_pools">[docs]</a>    <span class="k">def</span> <span class="nf">density_values_for_pools</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool_densities_sv</span><span class="p">,</span> <span class="n">pool_age_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the pool age densities over the time grid at ages given in </span>
<span class="sd">        pool_age_values.</span>

<span class="sd">        This function can be used to obtain the density values at mean or median</span>
<span class="sd">        values to draw a curve on top of the density surface. But actually this</span>
<span class="sd">        is now implemented in a much faster way based on the surface itself.</span>

<span class="sd">        Args:</span>
<span class="sd">            pool_age_densites_sv (Python function): A function that takes </span>
<span class="sd">                ``a``, ``t`` as arguments and returns a vector of pool contents </span>
<span class="sd">                with mass a at time t. Potentially coming from </span>
<span class="sd">                :func:`pool_age_densities_single_value`.</span>
<span class="sd">            pool_age_values (numpy.ndarray len(times) x nr_pools): The ages over</span>
<span class="sd">                the time-pool grid at which the density values are to be </span>
<span class="sd">                computed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: (len(times) x nr_pools) The pool density values over</span>
<span class="sd">            the time-pool grid based on the given age values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
    
        <span class="c1"># for each pool we have a different age value </span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">pool_age_values</span><span class="p">[:,</span><span class="n">pool</span><span class="p">]</span>
            <span class="c1">#z.append(np.array([pool_densities_sv(val[i], times[i])[pool] </span>
            <span class="c1">#                        for i in range(len(times))]))</span>
            <span class="n">new_z_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))):</span>
                <span class="n">new_z_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pool_densities_sv</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="n">pool</span><span class="p">])</span>

            <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_z_list</span><span class="p">))</span>

            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">z</span></div>

    <span class="c1"># return density values for mean, median, etc.</span>
    <span class="c1">#fixme: test</span>
<div class="viewcode-block" id="SmoothModelRun.density_values"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.density_values">[docs]</a>    <span class="k">def</span> <span class="nf">density_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">density_sv</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the density value over the time grid at ages given in values.</span>

<span class="sd">        This function can be used to obtain the density values at mean or median</span>
<span class="sd">        values to draw a curve on top of the density surface. But actually this</span>
<span class="sd">        is now implemented in a much faster way based on the surface itself.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_sv (Python function): A function that takes ``a``, ``t`` </span>
<span class="sd">                as arguments and returns density value with age a at time ``t``.</span>
<span class="sd">                Potentially coming from :func:`system_age_density_single_value`.</span>
<span class="sd">            values (numpy.array): The ages over the time grid at which the </span>
<span class="sd">                density values are to be computed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The density values over the time grid based </span>
<span class="sd">            on the given age values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">density_sv</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1">#dv_list = [f(i) for i in range(len(times))]</span>

        <span class="n">dv_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))):</span>
            <span class="n">dv_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dv_list</span><span class="p">)</span></div>


<div class="viewcode-block" id="SmoothModelRun.save_value_csv"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.save_value_csv">[docs]</a>    <span class="k">def</span> <span class="nf">save_value_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save values over the time grid to a csv file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The name of the csv file to be written.</span>
<span class="sd">            arr (numpy.array): The values to be saved over the time grid.</span>
<span class="sd">            times (np.array, optional): The time grid to be used.</span>
<span class="sd">                Defaults to ``None`` in which case the orginal time grid </span>
<span class="sd">                is used.</span>
<span class="sd">        Returns:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        
        <span class="n">melted</span> <span class="o">=</span> <span class="n">melt</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">[</span><span class="n">times</span><span class="p">])</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&quot;time&quot;, &quot;value&quot;&#39;</span>
        <span class="n">save_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">melted</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.save_density_csv"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.save_density_csv">[docs]</a>    <span class="k">def</span> <span class="nf">save_density_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">ages</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save density values over age-time grid to csv file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The name of the csv file to be written.</span>
<span class="sd">            density (numpy.ndarray len(ages) x len(times)): The density values</span>
<span class="sd">                to be saved over the age-time grid.</span>
<span class="sd">            ages (numpy.array): The ages corresponding to the indices in the</span>
<span class="sd">                zeroth dimension of the density ndarray.</span>
<span class="sd">            times (numpy.array, optional): An alternative time grid to be used.</span>
<span class="sd">                Defaults to ``None`` which means that the original time grid is </span>
<span class="sd">                going to be used.</span>

<span class="sd">        Returns:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">melt</span><span class="p">(</span><span class="n">density</span><span class="p">,</span> <span class="p">[</span><span class="n">ages</span><span class="p">,</span> <span class="n">times</span><span class="p">])</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&quot;age&quot;, &quot;time&quot;, &quot;value&quot;&#39;</span>
        <span class="n">save_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">melted</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span></div>
        

    <span class="c1">##### comma separated values input methods #####</span>

    
<div class="viewcode-block" id="SmoothModelRun.load_value_csv"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.load_value_csv">[docs]</a>    <span class="k">def</span> <span class="nf">load_value_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">melted</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


    <span class="c1">## combining pool and system structures ##</span>


<div class="viewcode-block" id="SmoothModelRun.combine_pools_and_system_values"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.combine_pools_and_system_values">[docs]</a>    <span class="k">def</span> <span class="nf">combine_pools_and_system_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pools_values</span><span class="p">,</span> <span class="n">system_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append the system values to the pool values as if they belonged to </span>
<span class="sd">        another pool.</span>

<span class="sd">        Args:</span>
<span class="sd">            pools_values (numpy.ndarray len(times) x nr_pools): The values to be</span>
<span class="sd">                saved over the time-pool grid.</span>
<span class="sd">            system_values (numpy.array): The system values to be saved over the</span>
<span class="sd">                time grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x (nr_pools+1) The pool and system values</span>
<span class="sd">            over the time-pool grid with the system added at the end as another</span>
<span class="sd">            pool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">values</span><span class="p">[:,:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pools_values</span>
        <span class="n">values</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">system_values</span>
    
        <span class="k">return</span> <span class="n">values</span></div>


    <span class="c1">## age ##</span>

    
<div class="viewcode-block" id="SmoothModelRun.load_pools_and_system_densities_csv"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.load_pools_and_system_densities_csv">[docs]</a>    <span class="k">def</span> <span class="nf">load_pools_and_system_densities_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">ages</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load pool and system age densities from a csv file.</span>

<span class="sd">        Attention: It is assumed that the data were saved before with the very </span>
<span class="sd">        same ages, times, and pools.</span>
<span class="sd">        Furthermore, it is assumed that the system value always follows the </span>
<span class="sd">        pool values.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The csv file from which the data are to be read.</span>
<span class="sd">            ages (numpy.array): The ages corresponding to the age indices. </span>
<span class="sd">                What is needed here is in fact only the length of the age grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(ages) x len(times) x (nr_pools+1) The density </span>
<span class="sd">            values for the pools and the system over the </span>
<span class="sd">            ages-times-(pools+system) grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ages</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> 
                            <span class="n">buffer</span><span class="o">=</span><span class="p">(</span><span class="n">melted</span><span class="p">[:,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>


<div class="viewcode-block" id="SmoothModelRun.load_density_csv"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.load_density_csv">[docs]</a>    <span class="k">def</span> <span class="nf">load_density_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">ages</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load density values from a csv file.</span>

<span class="sd">        Attention: It is assumed that the data were saved before with the very</span>
<span class="sd">        same ages, times, and pools.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The csv file from which the data are to be read.</span>
<span class="sd">            ages (numpy.array): The ages corresponding to the age indices. </span>
<span class="sd">                What is needed here is in fact only the length of the age grid.</span>
<span class="sd">            times (numpy.array, optional): The ages corresponding to the time</span>
<span class="sd">                indices. </span>
<span class="sd">                What is needed here is in fact only the length of the time grid.</span>
<span class="sd">                Defaults to ``None`` and the original times are being used.</span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(ages) x len(times) The density values over the </span>
<span class="sd">            ages-times grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="n">melted</span> <span class="o">=</span> <span class="n">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ages</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)),</span> 
                            <span class="n">buffer</span><span class="o">=</span><span class="p">(</span><span class="n">melted</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="SmoothModelRun.load_pools_and_system_value_csv"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.load_pools_and_system_value_csv">[docs]</a>    <span class="k">def</span> <span class="nf">load_pools_and_system_value_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load pool and system values from a csv file.</span>

<span class="sd">        Values could be the mean/median age, for example. One dimension less </span>
<span class="sd">        than a density.</span>

<span class="sd">        Attention: It is assumed that the data were saved before with the very</span>
<span class="sd">        same ages, times, and pools.</span>
<span class="sd">        Furthermore, it is assumed that the system value always follows the </span>
<span class="sd">        pool values.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The csv file from which the data are to be read.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: len(times) x (nr_pools+1) The values for the pools </span>
<span class="sd">            and the system over the times-(pools+system) grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">melted</span> <span class="o">=</span> <span class="n">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">values_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">melted</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">pool</span>
            <span class="n">values_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">melted</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">pool_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values_lst</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">melted</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">system_values</span> <span class="o">=</span> <span class="n">melted</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">pool_values</span><span class="p">,</span> <span class="n">system_values</span><span class="p">)</span></div>


    <span class="c1">##### plotting methods #####</span>

    
    <span class="c1">## solutions ##</span>


<div class="viewcode-block" id="SmoothModelRun.plot_solutions"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_solutions">[docs]</a>    <span class="k">def</span> <span class="nf">plot_solutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the solution trajectories.</span>
<span class="sd">    </span>
<span class="sd">        For each trajectory (nr_pools+1) a new subplot is created.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            fig (Matplotlib figure): The fig to which the subplots are added.</span>
<span class="sd">            fontsize (float, optional): Defaults to 10.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="c1">#fixme:</span>
    <span class="c1"># since time units and units are related to those</span>
    <span class="c1"># of the other fluxes it would be more consistent</span>
    <span class="c1"># to make them a property of SmoothModelRun and use</span>
    <span class="c1"># them in the other plots as well</span>

        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="c1">#soln = self.solve_old()</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>


        <span class="k">def</span> <span class="nf">make_ax_nice</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">title</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">)),</span> 
                            <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_content_unit</span><span class="p">(</span><span class="s1">&#39;content&#39;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">1.1</span><span class="p">)</span>
        

        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">soln</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">make_ax_nice</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s1">&#39;System&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="n">pool</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">soln</span><span class="p">[:,</span><span class="n">pool</span><span class="p">])</span>
            <span class="n">make_ax_nice</span><span class="p">(</span>
                <span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">pool</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>
   
 
<div class="viewcode-block" id="SmoothModelRun.plot_phase_plane"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_phase_plane">[docs]</a>    <span class="k">def</span> <span class="nf">plot_phase_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot one single phase plane.</span>

<span class="sd">        Args:</span>
<span class="sd">            ax (Matplotlib axis): The axis onto which the phase plane is </span>
<span class="sd">                plotted.</span>
<span class="sd">            i, j (int): The numbers of the pools for which the phase plane is </span>
<span class="sd">                plotted.</span>
<span class="sd">            fontsize (float, optional): Defaults to 10.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``ax`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="c1">#soln = self.solve_old()</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">soln</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">soln</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
        
        <span class="n">x0</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">x0</span><span class="p">],[</span><span class="n">y0</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

        <span class="n">x1</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">mpatches</span><span class="o">.</span><span class="n">FancyArrowPatch</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">),</span> 
                    <span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="n">mutation_scale</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_content_unit</span><span class="p">(</span>
            <span class="s2">&quot;$&quot;</span><span class="o">+</span><span class="n">latex</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">+</span><span class="s2">&quot;$&quot;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_content_unit</span><span class="p">(</span>
            <span class="s2">&quot;$&quot;</span><span class="o">+</span><span class="n">latex</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span><span class="o">+</span><span class="s2">&quot;$&quot;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span></div>


<div class="viewcode-block" id="SmoothModelRun.plot_phase_planes"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_phase_planes">[docs]</a>    <span class="k">def</span> <span class="nf">plot_phase_planes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot all phase planes.</span>

<span class="sd">        For each (i,j)-phase plane a new subplot is added.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Matplotlib figure): The fig to which the subplots are added.</span>
<span class="sd">            fontsize (float, optional): Defaults to 10.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        
        <span class="k">if</span> <span class="n">n</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">:</span>
<span class="c1">#            planes = [(i,j) for i in range(n) for j in range(i)]</span>
<span class="c1">#            rows, cols = arrange_subplots(len(planes))</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">plot_phase_plane</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">fontsize</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>

            <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>
    

    <span class="c1">## fluxes ##</span>
    

<div class="viewcode-block" id="SmoothModelRun.plot_internal_fluxes"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_internal_fluxes">[docs]</a>    <span class="k">def</span> <span class="nf">plot_internal_fluxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot all internal fluxes.</span>

<span class="sd">        For each internal flux a new subplot is added.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Matplotlib figure): The fig to which the subplots are added.</span>
<span class="sd">            fontsize (float, optional): Defaults to 10.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">internal_flux_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_flux_funcs</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">internal_flux_funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="c1">#n=self.nr_pools</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">internal_flux_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">internal_flux_funcs</span><span class="p">[</span><span class="n">key</span><span class="p">](</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">])</span>
    
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                <span class="s1">&#39;Flux from $&#39;</span> 
                <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> 
                <span class="o">+</span> <span class="s1">&#39;$ to $&#39;</span>
                <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> 
                <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">,</span>
                <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span>
                <span class="s1">&#39;$&#39;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_flux_unit</span><span class="p">(</span><span class="s1">&#39;flux&#39;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>


<div class="viewcode-block" id="SmoothModelRun.plot_external_output_fluxes"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_external_output_fluxes">[docs]</a>    <span class="k">def</span> <span class="nf">plot_external_output_fluxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot all external output fluxes.</span>

<span class="sd">        For each external output flux a new subplot is added.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Matplotlib figure): The fig to which the subplots are added.</span>
<span class="sd">            fontsize (float, optional): Defaults to 10.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">output_flux_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_output_flux_funcs</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_flux_funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">output_flux_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">output_flux_funcs</span><span class="p">[</span><span class="n">key</span><span class="p">](</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                <span class="s1">&#39;External outflux from $&#39;</span> 
                <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> 
                <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">,</span> 
                <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="s1">&#39;$&#39;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">),</span> 
                <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_flux_unit</span><span class="p">(</span><span class="s1">&#39;flux&#39;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>
                
    
<div class="viewcode-block" id="SmoothModelRun.plot_external_input_fluxes"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_external_input_fluxes">[docs]</a>    <span class="k">def</span> <span class="nf">plot_external_input_fluxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot all external inpput fluxes.</span>

<span class="sd">        For each external input flux a new subplot is added.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Matplotlib figure): The fig to which the subplots are added.</span>
<span class="sd">            fontsize (float, optional): Defaults to 10.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">input_flux_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_flux_funcs</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_flux_funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">input_flux_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">input_flux_funcs</span><span class="p">[</span><span class="n">key</span><span class="p">](</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                <span class="s1">&#39;External influx to $&#39;</span> 
                <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> 
                <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">,</span> 
                <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="s1">&#39;$&#39;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">),</span> 
                <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_flux_unit</span><span class="p">(</span><span class="s1">&#39;flux&#39;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>


    <span class="c1"># means # </span>


<div class="viewcode-block" id="SmoothModelRun.plot_mean_ages"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_mean_ages">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mean_ages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">start_mean_ages</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the time evolution of the mean ages for all pools and the </span>
<span class="sd">        system.</span>

<span class="sd">        For each pool and the system a separate subplot is created.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Matplotlib figure): The fig to which the subplots are added.</span>
<span class="sd">            start_mean_ages (numpy.array): Contains the start mean ages of the </span>
<span class="sd">                pools at time :math:`t_0`.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">start_age_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span>
                                <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_mean_ages</span><span class="p">))</span>
        <span class="n">time_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_variables</span>

        <span class="n">ma_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">age_moment_vector</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>
        <span class="n">sma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_age_moment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">make_ax_nice</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">title</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="n">time_symbol</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="s2">&quot;mean age&quot;</span><span class="p">))</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">sma</span><span class="p">)</span>
        <span class="n">make_ax_nice</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;System&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">ma_vector</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
            <span class="n">make_ax_nice</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">)</span>
                
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>


<div class="viewcode-block" id="SmoothModelRun.plot_mean_backward_transit_time"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_mean_backward_transit_time">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mean_backward_transit_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">start_mean_ages</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the time evolution of the mean backward transit time.</span>

<span class="sd">        For each pool and the system a separate subplot is created.</span>

<span class="sd">        Args:</span>
<span class="sd">            ax (Matplotlib axis): The ax onto which the plot is done.</span>
<span class="sd">            start_mean_ages (numpy.array): Contains the start mean ages of the </span>
<span class="sd">                pools at time :math:`t_0`.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``ax`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">start_age_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span>
                                <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_mean_ages</span><span class="p">))</span>
        <span class="n">time_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span>
        <span class="n">tr_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backward_transit_time_moment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">tr_val</span><span class="p">)</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Mean backward transit time&quot;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="n">time_symbol</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_time_unit</span><span class="p">(</span><span class="s2">&quot;mean BTT&quot;</span><span class="p">))</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span></div>


    <span class="c1">## densities ##</span>


    <span class="c1"># age #</span>

    
<div class="viewcode-block" id="SmoothModelRun.add_line_to_density_plot_plotly"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.add_line_to_density_plot_plotly">[docs]</a>    <span class="k">def</span> <span class="nf">add_line_to_density_plot_plotly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> 
            <span class="n">time_stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">on_surface</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">legend_on_surface</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">legend_bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a line to an existing Plotly density plot.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Plotly figure): Contains already a density plot to which the </span>
<span class="sd">                new line is added.</span>
<span class="sd">            data (numpy.array len(times)): The age data of the new line.</span>
<span class="sd">            color (#RRGGBB): The color of the new line.</span>
<span class="sd">            name (str): The name of the new line for the legend.</span>
<span class="sd">            time_stride (int, optional): Coarsity of the plot in the time </span>
<span class="sd">                direction to save memory. </span>
<span class="sd">                Defaults to 1 meaning that all times are plotted and no memory </span>
<span class="sd">                is saved.</span>
<span class="sd">            width (int, optional): Width of the new line. Defaults to 5.</span>
<span class="sd">            on_surface (bool, optional): If True, a new line with the given age</span>
<span class="sd">                data is plotted on top of the given density.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            bottom (bool optional): If True, a new line with the given age data</span>
<span class="sd">                is plotted in the xy-plane. </span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            legend_on_surface (bool, optional): If True, the line on the surface</span>
<span class="sd">                is mentioned in the legend.</span>
<span class="sd">                Has no effect if on_surface is False.</span>
<span class="sd">                Defaults to False.</span>
<span class="sd">            legend_bottom (bool, optional): If True, the line in the xy-plane is</span>
<span class="sd">                mentioned in the legend.</span>
<span class="sd">                Has no effect if bottom is False.</span>
<span class="sd">                Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">strided_data</span> <span class="o">=</span> <span class="n">stride</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">time_stride</span><span class="p">)</span>
        <span class="n">strided_times</span> <span class="o">=</span> <span class="n">stride</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">time_stride</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">bottom</span><span class="p">:</span>
            <span class="c1">#trace_bottom = go.Scatter3d(</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_scatter3d</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">x</span><span class="o">=-</span><span class="n">strided_times</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">strided_data</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">strided_times</span><span class="p">,</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;lines&#39;</span><span class="p">,</span>
            <span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="n">width</span>
                <span class="p">),</span>
            <span class="n">showlegend</span> <span class="o">=</span> <span class="n">legend_bottom</span>
            <span class="p">)</span>
            <span class="c1">#fig[&#39;data&#39;] += [trace_bottom]</span>

        <span class="k">if</span> <span class="n">on_surface</span><span class="p">:</span>
            <span class="c1"># compute the density values on the surface</span>
            <span class="c1">#strided_times = -fig[&#39;data&#39;][0][&#39;x&#39;]</span>
            <span class="n">strided_ages</span> <span class="o">=</span> <span class="n">fig</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
            <span class="n">density_data</span> <span class="o">=</span> <span class="n">fig</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>

            <span class="n">strided_z</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strided_times</span><span class="p">)):</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">strided_times</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span>
                <span class="n">age</span> <span class="o">=</span> <span class="n">strided_data</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span>

                <span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">age</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="n">strided_ages</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> 
                    <span class="p">(</span><span class="n">age</span> <span class="o">&gt;</span> <span class="n">strided_ages</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                    <span class="n">strided_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ti_lower</span> <span class="o">=</span> <span class="n">strided_times</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">time</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                    <span class="n">ti_upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">ti_lower</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">ti_lower</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">strided_times</span><span class="p">)</span> 
                                            <span class="k">else</span> <span class="n">ti_lower</span><span class="p">)</span>
                    <span class="n">time_lower</span> <span class="o">=</span> <span class="n">strided_times</span><span class="p">[</span><span class="n">ti_lower</span><span class="p">]</span>
                    <span class="n">time_upper</span> <span class="o">=</span> <span class="n">strided_times</span><span class="p">[</span><span class="n">ti_upper</span><span class="p">]</span>
    
                    <span class="n">ai_lower</span> <span class="o">=</span> <span class="n">strided_ages</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">age</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                    <span class="n">ai_upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">ai_lower</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">ai_lower</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">strided_ages</span><span class="p">)</span> 
                                            <span class="k">else</span> <span class="n">ai_lower</span><span class="p">)</span>
                    <span class="n">age_lower</span> <span class="o">=</span> <span class="n">strided_ages</span><span class="p">[</span><span class="n">ai_lower</span><span class="p">]</span>
                    <span class="n">age_upper</span> <span class="o">=</span> <span class="n">strided_ages</span><span class="p">[</span><span class="n">ai_upper</span><span class="p">]</span>
    
                    <span class="n">bl_density_value</span> <span class="o">=</span> <span class="n">density_data</span><span class="p">[</span><span class="n">ai_lower</span><span class="p">,</span> <span class="n">ti_lower</span><span class="p">]</span>
                    <span class="n">br_density_value</span> <span class="o">=</span> <span class="n">density_data</span><span class="p">[</span><span class="n">ai_lower</span><span class="p">,</span> <span class="n">ti_upper</span><span class="p">]</span>
                    <span class="n">bottom_density_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">bl_density_value</span> <span class="o">+</span> <span class="p">(</span><span class="n">time</span><span class="o">-</span><span class="n">time_lower</span><span class="p">)</span>
                                            <span class="o">/</span><span class="p">(</span><span class="n">time_upper</span><span class="o">-</span><span class="n">time_lower</span><span class="p">)</span><span class="o">*</span>
                                            <span class="p">(</span><span class="n">br_density_value</span><span class="o">-</span><span class="n">bl_density_value</span><span class="p">))</span>
    
                    <span class="n">tl_density_value</span> <span class="o">=</span> <span class="n">density_data</span><span class="p">[</span><span class="n">ai_upper</span><span class="p">,</span> <span class="n">ti_lower</span><span class="p">]</span>
                    <span class="n">tr_density_value</span> <span class="o">=</span> <span class="n">density_data</span><span class="p">[</span><span class="n">ai_upper</span><span class="p">,</span> <span class="n">ti_upper</span><span class="p">]</span>
                    <span class="n">top_density_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl_density_value</span> <span class="o">+</span> <span class="p">(</span><span class="n">time</span><span class="o">-</span><span class="n">time_lower</span><span class="p">)</span><span class="o">/</span>
                                            <span class="p">(</span><span class="n">time_upper</span><span class="o">-</span><span class="n">time_lower</span><span class="p">)</span><span class="o">*</span>
                                            <span class="p">(</span><span class="n">tr_density_value</span><span class="o">-</span><span class="n">tl_density_value</span><span class="p">))</span>
    
                    <span class="n">density_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">bottom_density_value</span> <span class="o">+</span> 
                                    <span class="p">(</span><span class="n">age</span><span class="o">-</span><span class="n">age_lower</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">age_upper</span><span class="o">-</span><span class="n">age_lower</span><span class="p">)</span><span class="o">*</span>
                                    <span class="p">(</span><span class="n">top_density_value</span><span class="o">-</span><span class="n">bottom_density_value</span><span class="p">))</span>
                    <span class="n">strided_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">density_value</span><span class="p">)</span>

            <span class="c1">#trace_on_surface = go.Scatter3d(</span>
            <span class="c1">#    name=name,</span>
            <span class="c1">#    x=-strided_times, y=strided_data, z=strided_z,</span>
            <span class="c1">#    mode = &#39;lines&#39;,</span>
            <span class="c1">#    line=dict(</span>
            <span class="c1">#        color=color,</span>
            <span class="c1">#        width=width</span>
            <span class="c1">#        ),</span>
            <span class="c1">#    showlegend = legend_on_surface</span>
            <span class="c1">#)</span>
            <span class="c1">#fig[&#39;data&#39;] += [trace_on_surface]</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_scatter3d</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">x</span><span class="o">=-</span><span class="n">strided_times</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">strided_data</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">strided_z</span><span class="p">,</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;lines&#39;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">width</span><span class="o">=</span><span class="n">width</span>
                    <span class="p">),</span>
                <span class="n">showlegend</span> <span class="o">=</span> <span class="n">legend_on_surface</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.plot_3d_density_plotly"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.plot_3d_density_plotly">[docs]</a>    <span class="k">def</span> <span class="nf">plot_3d_density_plotly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">density_data</span><span class="p">,</span> <span class="n">ages</span><span class="p">,</span> 
            <span class="n">age_stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_stride</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a 3-dimendional density plot with Plotly.</span>

<span class="sd">        The colors are created such that they are constant along the age-time </span>
<span class="sd">        diagonal.</span>
<span class="sd">        Thus, equal colors mark equal entry time into the system.</span>

<span class="sd">        Args:</span>
<span class="sd">            title (str): The title of the new figure.</span>
<span class="sd">            density_data (numpy.ndarray len(ages) x len(times)): </span>
<span class="sd">                The density data to be plotted.</span>
<span class="sd">            age_stride (int, optional): Coarsity of the plot in the age </span>
<span class="sd">                direction to save memory. </span>
<span class="sd">                Defaults to 1 meaning that all times are plotted and no memory</span>
<span class="sd">                is saved.</span>
<span class="sd">            time_stride (int, optional): Coarsity of the plot in the time </span>
<span class="sd">                direction to save memory. </span>
<span class="sd">                Defaults to 1 meaning that all times are plotted and no memory </span>
<span class="sd">                is saved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Plotly figure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">layout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_density_plot_plotly</span><span class="p">(</span>
                                <span class="n">density_data</span><span class="p">,</span> <span class="n">ages</span><span class="p">,</span> <span class="n">age_stride</span><span class="p">,</span> <span class="n">time_stride</span><span class="p">)</span>
        <span class="n">layout</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">title</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">fig</span></div>

<span class="c1">#    def add_equilibrium_surface_plotly(self, fig, opacity=0.7, index=0):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        The function has been renamed since </span>
<span class="c1">#            1. It is not certain that the system has an equilibrium at all. </span>
<span class="c1">#            2. The age distribution at the beginning of a model run does not have to </span>
<span class="c1">#               represent an equilibrium age distribution</span>
<span class="c1">#               (even if the system was in equilibrium at t0 in the sense that the pool contents do not change any more the age distribution still could.)</span>
<span class="c1">#               </span>
<span class="c1">#            please call add_constant_age_distribution_surface_plotly instead! </span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        txt=self.add_equilibrium_surface_plotly.__doc__</span>
<span class="c1">#        deprecation_warning(txt)</span>
<span class="c1">#        self.add_constant_age_distribution_surface_plotly(fig, opacity, index)</span>

<div class="viewcode-block" id="SmoothModelRun.add_constant_age_distribution_surface_plotly"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.add_constant_age_distribution_surface_plotly">[docs]</a>    <span class="k">def</span> <span class="nf">add_constant_age_distribution_surface_plotly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a grey and transparent density surface to an existing</span>
<span class="sd">        Plotly density plot.</span>

<span class="sd">        If index is not specified it is assumed to be 0 and the values correspond to the first time in the times porperty of the model run (the age distribution at the beginning) </span>
<span class="sd">        and repeated for all times.</span>
<span class="sd">        The plotted surface represents an age distribution that is constant in time.</span>
<span class="sd">        It is intended to increase the visibility of changes in the age distribution with time.</span>
<span class="sd">        Note that this constant age distribution does NOT necessarily correspond to a </span>
<span class="sd">        possible (constant) development of the system. </span>
<span class="sd">        This would only be true if the system was in equilibrium and the age distribution </span>
<span class="sd">        was the equilibrium age distribution.</span>
<span class="sd">        While this special case is a very interesting application this function does not </span>
<span class="sd">        assertain that such an equlibrium situation is even possible.</span>

<span class="sd">        Args:</span>
<span class="sd">            fig (Plotly figure): The existing density plot to which the </span>
<span class="sd">                surface is added.</span>
<span class="sd">            opacity (between 0 and 1, optional): The opacity of the new surface.</span>
<span class="sd">                Defaults to 0.9.</span>
<span class="sd">                Unfortunately, the opacity option does not seem to work </span>
<span class="sd">                properly.</span>
<span class="sd">            index (int, optional): The time index from which the age distribution </span>
<span class="sd">                data is taken.</span>
<span class="sd">                Defaults to 0 such that the constant distribution is computed  at time :math:`t_0`.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">            Instead ``fig`` is changed in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">fig</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">z</span><span class="p">[:,</span><span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span><span class="n">index</span><span class="p">]</span>
        <span class="c1">#eq_surface_data = go.Surface(</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_surface</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> 
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> 
            <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> 
            <span class="n">showscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">opacity</span> <span class="o">=</span> <span class="n">opacity</span><span class="p">,</span>
            <span class="n">surfacecolor</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z</span><span class="p">))</span></div>
        <span class="c1">#fig[&#39;data&#39;].append(eq_surface_data)</span>


    <span class="c1">##### cumulative distribution methods #####</span>


<div class="viewcode-block" id="SmoothModelRun.cumulative_pool_age_distributions_single_value"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.cumulative_pool_age_distributions_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">cumulative_pool_age_distributions_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function for the cumulative pool age distributions.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a numpy.array containing the masses with the given </span>
<span class="sd">                age at time :math:`t_0`. Defaults to None.</span>
<span class="sd">            F0 (Python function): A function of age that returns a numpy.array </span>
<span class="sd">                containing the masses with age less than or equal to the age at </span>
<span class="sd">                time :math:`t_0`. Defaults to None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are ``None``. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``F_sv``: ``F_sv(a,t)`` is the vector of pool </span>
<span class="sd">            masses (``numpy.array``) with age less than or equal to ``a`` at </span>
<span class="sd">            time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="c1">#soln = self.solve_old()</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_age_densities</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Either F0 or start_age_densities must be given.&#39;</span><span class="p">))</span>

        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#sol_funcs = self.sol_funcs()</span>
        <span class="c1">#sol_funcs_array = lambda t: np.array([sol_funcs[pool](t) </span>
        <span class="c1">#                                           for pool in range(n)])</span>
        <span class="c1">#sol_funcs_array = self.solve_single_value_old()</span>
        <span class="n">sol_funcs_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">start_age_densities</span>
            <span class="n">F0</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">p0</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                                        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>

        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>

        <span class="k">def</span> <span class="nf">G_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>
            <span class="c1">#print(t, t0, a-(t-t0))</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">F0</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">)))</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_state_transition_operator_cache&#39;</span><span class="p">)</span>
            <span class="c1">#print(c, &#39;G&#39;, res, t, t0, a, a-(t-t0))</span>
            <span class="k">return</span> <span class="n">res</span>


        <span class="k">def</span> <span class="nf">H_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="c1"># count everything from beginning?</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">t</span><span class="o">-</span><span class="n">t0</span>

            <span class="c1"># mass at time t</span>
            <span class="c1">#x_t_old = np.array([sol_funcs[pool](t) for pool in range(n)])</span>
            <span class="n">x_t</span> <span class="o">=</span> <span class="n">sol_funcs_array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="c1"># mass at time t-a</span>
            <span class="c1">#x_tma_old = [np.float(sol_funcs[pool](t-a)) for pool in range(n)]</span>
            <span class="n">x_tma</span> <span class="o">=</span> <span class="n">sol_funcs_array</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
            <span class="c1"># what remains from x_tma at time t</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">x_tma</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_state_transition_operator_cache&#39;</span><span class="p">)</span>
            <span class="c1">#print(c, &#39;H&#39;, m, t, a, x_t, x_tma)</span>
            <span class="c1"># difference is not older than t-a</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">x_t</span><span class="o">-</span><span class="n">m</span>
            <span class="c1"># cut off accidental negative values</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">G_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">H_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
            <span class="c1">#print(a, t, res)</span>
            <span class="c1">#print(&#39;G&#39;, G_sv(a,t), &#39;H&#39;, H_sv(a,t))</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">F</span></div>

<div class="viewcode-block" id="SmoothModelRun.cumulative_system_age_distribution_single_value"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.cumulative_system_age_distribution_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">cumulative_system_age_distribution_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function for the cumulative system age distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a numpy.array containing the masses with the given </span>
<span class="sd">                age at time :math:`t_0`. Defaults to None.</span>
<span class="sd">            F0 (Python function): A function of age that returns a numpy.array </span>
<span class="sd">                containing the masses with age less than or equal to the age at </span>
<span class="sd">                time :math:`t_0`. Defaults to None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are None. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``F_sv``: ``F_sv(a, t)`` is the mass in the system </span>
<span class="sd">            with age less than or equal to ``a`` at time ``t``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="c1">#soln = self.solve_old()</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_age_densities</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>
        
        <span class="k">if</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Either F0 or start_age_densities must be given.&#39;</span><span class="p">))</span>

        <span class="n">F_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_pool_age_distributions_single_value</span><span class="p">(</span>
                <span class="n">start_age_densities</span><span class="o">=</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="n">F0</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">F_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>

    <span class="c1">#fixme: test</span>
<div class="viewcode-block" id="SmoothModelRun.cumulative_backward_transit_time_distribution_single_value"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.cumulative_backward_transit_time_distribution_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">cumulative_backward_transit_time_distribution_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">start_age_densities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function for the cumulative backward transit time </span>
<span class="sd">        distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age</span>
<span class="sd">                that returns a numpy.array containing the masses with the given</span>
<span class="sd">                age at time :math:`t_0`. Defaults to None.</span>
<span class="sd">            F0 (Python function): A function of age that returns a numpy.array</span>
<span class="sd">                containing the masses with age less than or equal to the age at</span>
<span class="sd">                time :math:`t_0`. Defaults to None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are ``None``. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``F_sv``: ``F_sv(a, t)`` is the mass leaving the </span>
<span class="sd">            system at time ``t`` with age less than or equal to ``a``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Either F0 or start_age_densities must be given.&#39;</span><span class="p">))</span>

        <span class="n">F_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_pool_age_distributions_single_value</span><span class="p">(</span>
                <span class="n">start_age_densities</span><span class="o">=</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="n">F0</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_rate_vector_at_t</span>

        <span class="k">def</span> <span class="nf">F_btt_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">F_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1">#print(a, t, res)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">F_btt_sv</span></div>

    <span class="c1">#fixme: test</span>
<div class="viewcode-block" id="SmoothModelRun.cumulative_forward_transit_time_distribution_single_value_func"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.cumulative_forward_transit_time_distribution_single_value_func">[docs]</a>    <span class="k">def</span> <span class="nf">cumulative_forward_transit_time_distribution_single_value_func</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cut_off</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function for the cumulative forward transit time </span>
<span class="sd">        distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            cut_off (bool, optional): If ``True``, no density values are going </span>
<span class="sd">                to be computed after the end of the time grid, instead </span>
<span class="sd">                ``numpy.nan`` will be returned. </span>
<span class="sd">                Defaults to ``True``.</span>
<span class="sd">                ``False`` might lead to unexpected behavior.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python function ``F_sv``: ``F_sv(a, t)`` is the mass leaving the </span>
<span class="sd">            system at time ``t+a`` with age less than or equal to ``a``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">t_max</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="n">u_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">F_ftt_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="c1">#print(a, t, a+t&gt;t_max)</span>
            <span class="k">if</span> <span class="n">cut_off</span> <span class="ow">and</span> <span class="n">a</span><span class="o">+</span><span class="n">t</span><span class="o">&gt;</span><span class="n">t_max</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">u_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1">#print(a, t, u, res)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">F_ftt_sv</span></div>


    <span class="c1">##### quantiles #####</span>


<div class="viewcode-block" id="SmoothModelRun.pool_age_distributions_quantiles"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.pool_age_distributions_quantiles">[docs]</a>    <span class="k">def</span> <span class="nf">pool_age_distributions_quantiles</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">quantile</span><span class="p">,</span>
            <span class="n">start_values</span>        <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
            <span class="n">start_age_densities</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">F0</span>                  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">method</span>              <span class="o">=</span> <span class="s1">&#39;brentq&#39;</span><span class="p">,</span>
            <span class="n">tol</span>                 <span class="o">=</span> <span class="mf">1e-8</span>
        <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return pool age distribution quantiles over the time grid.</span>

<span class="sd">        The compuation is done by computing the generalized inverse of the </span>
<span class="sd">        respective cumulative distribution using a nonlinear root search </span>
<span class="sd">        algorithm. Depending on how slowly the cumulative distribution can be </span>
<span class="sd">        computed, this can take quite some time.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            start_values (numpy.ndarray, len(times) x nr_pools, optional): </span>
<span class="sd">                For each pool an array over the time grid of start values for </span>
<span class="sd">                the nonlinear search.</span>
<span class="sd">                Good values are slighty greater than the solution values.</span>
<span class="sd">                Defaults to an array of zeros for each pool</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a ``numpy.array`` containing the masses with the </span>
<span class="sd">                given age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            F0 (Python function): A function of age that returns a </span>
<span class="sd">                ``numpy.array`` containing the masses with age less than or</span>
<span class="sd">                equal to the age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            method (str): The method that is used for finding the roots of a </span>
<span class="sd">                nonlinear function. Either &#39;brentq&#39; or &#39;newton&#39;. </span>
<span class="sd">                Defaults to &#39;brentq&#39;.</span>
<span class="sd">            tol (float): The tolerance used in the numerical root search </span>
<span class="sd">                algorithm. A low tolerance decreases the computation speed </span>
<span class="sd">                tremendously, so a value of ``1e-01`` might already be fine. </span>
<span class="sd">                Defaults to ``1e-08``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are ``None``. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: (len(times) x nr_pools)</span>
<span class="sd">            The computed quantile values over the time-pool grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_age_densities</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Either F0 or start_age_densities must be given.&#39;</span><span class="p">))</span>

        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="k">if</span> <span class="n">start_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>

        <span class="n">F_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_pool_age_distributions_single_value</span><span class="p">(</span>
            <span class="n">start_age_densities</span> <span class="o">=</span> <span class="n">start_age_densities</span><span class="p">,</span>
            <span class="n">F0</span>                  <span class="o">=</span> <span class="n">F0</span>
        <span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pool:&#39;</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span>
            <span class="n">F_sv_pool</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">F_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)[</span><span class="n">pool</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distribution_quantiles</span><span class="p">(</span>
                    <span class="n">quantile</span><span class="p">,</span>
                    <span class="n">F_sv_pool</span><span class="p">,</span>
                    <span class="n">norm_consts</span>  <span class="o">=</span> <span class="n">soln</span><span class="p">[:,</span><span class="n">pool</span><span class="p">],</span>
                    <span class="n">start_values</span> <span class="o">=</span> <span class="n">start_values</span><span class="p">[:,</span><span class="n">pool</span><span class="p">],</span>
                    <span class="n">method</span>       <span class="o">=</span> <span class="n">method</span><span class="p">,</span>
                    <span class="n">tol</span>          <span class="o">=</span> <span class="n">tol</span>
                <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="SmoothModelRun.system_age_distribution_quantiles"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.system_age_distribution_quantiles">[docs]</a>    <span class="k">def</span> <span class="nf">system_age_distribution_quantiles</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">quantile</span><span class="p">,</span>
            <span class="n">start_values</span>        <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
            <span class="n">start_age_densities</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">F0</span>                  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">method</span>              <span class="o">=</span> <span class="s1">&#39;brentq&#39;</span><span class="p">,</span>
            <span class="n">tol</span>                 <span class="o">=</span> <span class="mf">1e-8</span>
        <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return system age distribution quantiles over the time grid.</span>

<span class="sd">        The compuation is done by computing the generalized inverse of the </span>
<span class="sd">        respective cumulative distribution using a nonlinear root search </span>
<span class="sd">        algorithm. Depending on how slowly the cumulative distribution can be </span>
<span class="sd">        computed, this can take quite some time.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            start_values (numpy.array, optional): An array over the time grid of</span>
<span class="sd">                start values for the nonlinear search.</span>
<span class="sd">                Good values are slighty greater than the solution values.</span>
<span class="sd">                Must have the same length as ``times``.</span>
<span class="sd">                Defaults to an array of zeros.</span>
<span class="sd">            start_age_densities (Python function, optional): A function of age </span>
<span class="sd">                that returns a ``numpy.array`` containing the masses with the </span>
<span class="sd">                given age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            F0 (Python function): A function of age that returns a </span>
<span class="sd">                ``numpy.array`` containing the masses with age less than or </span>
<span class="sd">                equal to the age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            method (str): The method that is used for finding the roots of a </span>
<span class="sd">                nonlinear function. Either &#39;brentq&#39; or &#39;newton&#39;. </span>
<span class="sd">                Defaults to &#39;brentq&#39;.</span>
<span class="sd">            tol (float): The tolerance used in the numerical root search </span>
<span class="sd">                algorithm. A low tolerance decreases the computation speed </span>
<span class="sd">                tremendously, so a value of ``1e-01`` might already be fide. </span>
<span class="sd">                Defaults to ``1e-08``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If both ``start_age_densities`` and ``F0`` are ``None``. </span>
<span class="sd">                One must be given.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The computed quantile values over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_age_densities</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Either F0 or start_age_densities must be given.&#39;</span><span class="p">))</span>
        
        <span class="n">F_sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_system_age_distribution_single_value</span><span class="p">(</span>
            <span class="n">start_age_densities</span> <span class="o">=</span> <span class="n">start_age_densities</span><span class="p">,</span>
            <span class="n">F0</span>                  <span class="o">=</span> <span class="n">F0</span>
        <span class="p">)</span>
        <span class="c1">#soln = self.solve_old()</span>
        <span class="n">start_age_moments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments_from_densities</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_age_densities</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">start_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">start_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_age_moment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_age_moments</span><span class="p">)</span>

        <span class="n">a_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution_quantiles</span><span class="p">(</span>
            <span class="n">quantile</span><span class="p">,</span> 
            <span class="n">F_sv</span><span class="p">,</span> 
            <span class="n">norm_consts</span>  <span class="o">=</span> <span class="n">soln</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> 
            <span class="n">start_values</span> <span class="o">=</span> <span class="n">start_values</span><span class="p">,</span> 
            <span class="n">method</span>       <span class="o">=</span> <span class="n">method</span><span class="p">,</span>
            <span class="n">tol</span>          <span class="o">=</span> <span class="n">tol</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">a_star</span></div>


<div class="viewcode-block" id="SmoothModelRun.distribution_quantiles"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.distribution_quantiles">[docs]</a>    <span class="k">def</span> <span class="nf">distribution_quantiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="p">,</span> <span class="n">F_sv</span><span class="p">,</span> <span class="n">norm_consts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;brentq&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return distribution quantiles over the time grid of a given </span>
<span class="sd">        distribution.</span>

<span class="sd">        The compuation is done by computing the generalized inverse of the </span>
<span class="sd">        respective cumulative distribution using a nonlinear root search </span>
<span class="sd">        algorithm. Depending on how slowly the cumulative distribution can be </span>
<span class="sd">        computed, this can take quite some time.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            F_sv (Python function): A function of age ``a`` and time ``t`` that </span>
<span class="sd">                returns the mass that is of age less than or equal to ``a`` at </span>
<span class="sd">                time ``t``.</span>
<span class="sd">            norm_consts (numpy.array, optional): An array over the time grid of</span>
<span class="sd">                total masses over all ages. </span>
<span class="sd">                Defaults to an array of ones assuming given probability </span>
<span class="sd">                distributions.</span>
<span class="sd">            start_values (numpy.array, optional): An array over the time grid of</span>
<span class="sd">                start values for the nonlinear search.</span>
<span class="sd">                Good values are slighty greater than the solution values.</span>
<span class="sd">                Must have the same length as ``times``.</span>
<span class="sd">                Defaults to an array of zeros.</span>
<span class="sd">            times (numpy.array, optional): Time grid on which to compute the</span>
<span class="sd">                quantiles.</span>
<span class="sd">                Defaults to ``None`` in which case the orignal time grid </span>
<span class="sd">                is used.</span>
<span class="sd">            method (str): The method that is used for finding the roots of a </span>
<span class="sd">                nonlinear function. Either &#39;brentq&#39; or &#39;newton&#39;. </span>
<span class="sd">                Defaults to &#39;brentq&#39;.</span>
<span class="sd">            tol (float): The tolerance used in the numerical root search </span>
<span class="sd">                algorithm. A low tolerance decreases the computation speed </span>
<span class="sd">                tremendously, so a value of ``1e-01`` might already be fine. </span>
<span class="sd">                Defaults to ``1e-08``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: The computed quantile values over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        
        <span class="k">if</span> <span class="n">start_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">times</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">norm_consts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">norm_consts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">times</span><span class="p">,))</span>

        <span class="k">def</span> <span class="nf">quantile_at_ti</span><span class="p">(</span><span class="n">ti</span><span class="p">):</span>
            <span class="c1">#print(&#39;ti&#39;, ti)</span>
            <span class="k">if</span> <span class="n">norm_consts</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">res</span> <span class="o">=</span>  <span class="n">quantile</span><span class="o">*</span><span class="n">norm_consts</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span> <span class="o">-</span> <span class="n">F_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">])</span>
                <span class="c1">#print(&#39;a:&#39;, a,&#39;t&#39;, times[ti], &#39;g(a):&#39;, res, &#39;nc&#39;, </span>
                <span class="c1">#           norm_consts[ti], &#39;F_sv&#39;, F_sv(a, times[ti]))</span>
                <span class="k">return</span> <span class="n">res</span>

            <span class="n">start_age</span> <span class="o">=</span> <span class="n">start_values</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;newton&#39;</span><span class="p">:</span> 
                <span class="n">a_star</span> <span class="o">=</span> <span class="n">newton</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">start_age</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;brentq&#39;</span><span class="p">:</span> 
                <span class="n">a_star</span> <span class="o">=</span> <span class="n">generalized_inverse_CDF</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F_sv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">]),</span> 
                                                 <span class="n">quantile</span><span class="o">*</span><span class="n">norm_consts</span><span class="p">[</span><span class="n">ti</span><span class="p">],</span> 
                                                 <span class="n">start_dist</span><span class="o">=</span><span class="n">start_age</span><span class="p">,</span> 
                                                 <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">a_star</span>

        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="c1">#q_lst = [quantile_at_ti(ti) for ti in range(len(times))]</span>

        <span class="n">q_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))):</span>
            <span class="n">q_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quantile_at_ti</span><span class="p">(</span><span class="n">ti</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">q_lst</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.distribution_quantile"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.distribution_quantile">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">distribution_quantile</span><span class="p">(</span><span class="n">quantile</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> 
            <span class="n">norm_const</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;brentq&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return distribution quantile (one single value) of a given distribution.</span>

<span class="sd">        The compuation is done by computing the generalized inverse of the </span>
<span class="sd">        respective cumulative distribution using a nonlinear root search </span>
<span class="sd">        algorithm.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            F (Python function): A function of age ``a`` that </span>
<span class="sd">                returns the mass that is of age less than or equal to ``a``.</span>
<span class="sd">            norm_const (numpy.array, optional): The amount of total mass of the</span>
<span class="sd">                distribution. </span>
<span class="sd">                Defaults to one assuming a given probability distribution.</span>
<span class="sd">            start_value (float, optional): A start value for the nonlinear</span>
<span class="sd">                search.</span>
<span class="sd">                A good values is slighty greater than the solution value.</span>
<span class="sd">                Defaults to zero.</span>
<span class="sd">            method (str): The method that is used for finding the roots of a </span>
<span class="sd">                nonlinear function. Either &#39;brentq&#39; or &#39;newton&#39;. </span>
<span class="sd">                Defaults to &#39;brentq&#39;.</span>
<span class="sd">            tol (float): The tolerance used in the numerical root search </span>
<span class="sd">                algorithm. A low tolerance decreases the computation speed </span>
<span class="sd">                tremendously, so a value of ``1e-01`` might already be fine. </span>
<span class="sd">                Defaults to ``1e-08``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The computed quantile value of the distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_value</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">norm_const</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">norm_const</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">def</span> <span class="nf">quantile_f</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">norm_const</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">res</span> <span class="o">=</span>  <span class="n">quantile</span><span class="o">*</span><span class="n">norm_const</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="c1">#print(&#39;a:&#39;, a,&#39;t&#39;, times[ti], &#39;g(a):&#39;, res, &#39;nc&#39;, </span>
                <span class="c1">#           norm_consts[ti], &#39;F&#39;, F(a, times[ti]))</span>
                <span class="k">return</span> <span class="n">res</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;newton&#39;</span><span class="p">:</span> 
                <span class="n">a_star</span> <span class="o">=</span> <span class="n">newton</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">start_value</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;brentq&#39;</span><span class="p">:</span> 
                <span class="n">a_star</span> <span class="o">=</span> <span class="n">generalized_inverse_CDF</span><span class="p">(</span>
                           <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> 
                           <span class="n">quantile</span><span class="o">*</span><span class="n">norm_const</span><span class="p">,</span> 
                           <span class="n">start_dist</span><span class="o">=</span><span class="n">start_value</span><span class="p">,</span> 
                           <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
                        <span class="p">)</span>

            <span class="k">return</span> <span class="n">a_star</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">quantile_f</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">q</span></div>


    <span class="c1">## by ode ##</span>


<div class="viewcode-block" id="SmoothModelRun.pool_age_distributions_quantiles_by_ode"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.pool_age_distributions_quantiles_by_ode">[docs]</a>    <span class="k">def</span> <span class="nf">pool_age_distributions_quantiles_by_ode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="p">,</span> 
            <span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check_time_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return pool age distribution quantiles over the time grid.</span>

<span class="sd">        The compuation is done by solving an ODE for each pool as soon as the </span>
<span class="sd">        pool is nonempty.</span>
<span class="sd">        The initial value is obtained by computing the generalized inverse of </span>
<span class="sd">        the pool age distribution by a numerical root search algorithm.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            start_age_densities (Python function): A function of age </span>
<span class="sd">                that returns a ``numpy.array`` containing the masses with the </span>
<span class="sd">                given age at time :math:`t_0`. </span>
<span class="sd">            F0 (Python function, optional): A function of age that returns a </span>
<span class="sd">                ``numpy.array`` containing the masses with age less than or </span>
<span class="sd">                equal to the age at time :math:`t_0`. </span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>
<span class="sd">            check_time_indices (numpy.array, optional): Indices of the tiime</span>
<span class="sd">                 grid on which the ODE result are checked against an explicit</span>
<span class="sd">                 solution computed by the pseudo-inverse of the cumulative </span>
<span class="sd">                distribution function.</span>
<span class="sd">                Defaults to ``None`` in which case no check is performed.</span>
<span class="sd">            kwargs: Passed to the ``solve_ivp``, e.g., ``method`` </span>
<span class="sd">                or ``max_step``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: (len(times) x nr_pools) The computed quantile values </span>
<span class="sd">            over the time-pool grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pool:&#39;</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pool_age_distribution_quantiles_pool_by_ode</span><span class="p">(</span>
                    <span class="n">quantile</span><span class="p">,</span> 
                    <span class="n">pool</span><span class="p">,</span>
                    <span class="n">start_age_densities</span><span class="p">,</span>
                    <span class="n">F0</span><span class="o">=</span><span class="n">F0</span><span class="p">,</span>
                    <span class="n">check_time_indices</span><span class="o">=</span><span class="n">check_time_indices</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="SmoothModelRun.x_solve_func_skew"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.x_solve_func_skew">[docs]</a>    <span class="k">def</span> <span class="nf">x_solve_func_skew</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">block_ode</span><span class="p">,</span><span class="n">x_block_name</span><span class="p">,</span><span class="n">phi_block_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_x_phi_block_ode</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">x_tmax</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">block_ode</span><span class="p">,</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">),</span>
            <span class="n">x_block_name</span><span class="p">,</span>
            <span class="n">phi_block_name</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SmoothModelRun.pool_age_distribution_quantiles_pool_by_ode"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.pool_age_distribution_quantiles_pool_by_ode">[docs]</a>    <span class="k">def</span> <span class="nf">pool_age_distribution_quantiles_pool_by_ode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> 
            <span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check_time_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return pool age distribution quantile over the time grid for one </span>
<span class="sd">        single pool.</span>

<span class="sd">        The compuation is done by solving an ODE as soon as the pool is </span>
<span class="sd">        nonempty.</span>
<span class="sd">        The initial value is obtained by computing the generalized inverse of </span>
<span class="sd">        the pool age distribution by a numerical root search algorithm.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            pool (int): The number of the pool for which the age quantile is to </span>
<span class="sd">                be computed.</span>
<span class="sd">            start_age_densities (Python function): A function of age </span>
<span class="sd">                that returns a ``numpy.array`` containing the masses with the </span>
<span class="sd">                given age at time :math:`t_0`. </span>
<span class="sd">            F0 (Python function, optional): A function of age that returns a </span>
<span class="sd">                ``numpy.array`` containing the masses with age less than or </span>
<span class="sd">                equal to the age at time :math:`t_0`. </span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            check_time_indices (numpy.array, optional): Indices of the tiime</span>
<span class="sd">                 grid on which the ODE result are checked against an explicit</span>
<span class="sd">                 solution computed by the pseudo-inverse of the cumulative </span>
<span class="sd">                distribution function.</span>
<span class="sd">                Defaults to ``None`` in which case no check is performed.</span>
<span class="sd">            kwargs: Passed to the ``solve_ivp``, e.g., ``method`` </span>
<span class="sd">                    or ``max_step``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If ``start_age_densities`` is ``None``. </span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: (len(times)) The computed quantile values over the </span>
<span class="sd">            time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#soln = self.solve_old()</span>
        <span class="n">vec_sol_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_solve_func_skew</span><span class="p">()</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="n">vec_sol_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
        <span class="n">empty</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pool</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;start_age_densities must be given&#39;</span><span class="p">))</span>
        
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span> <span class="ow">and</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">start_age_densities</span>
            <span class="n">F0</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">p0</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
        
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_age_densities_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>
        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_pool_age_distributions_single_value</span><span class="p">(</span>
                <span class="n">start_age_densities</span><span class="o">=</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="n">F0</span><span class="p">)</span>
        <span class="c1">#sol_funcs = self.solve_single_value_old()</span>
        <span class="c1">#vec_sol_func = self.solve_func()</span>

        <span class="c1"># find last time index such that the pool is empty --&gt; ti</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">]</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">content</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ti</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span> 
            <span class="n">ti</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">content</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">ti</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ti</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),))</span>
  
        <span class="k">if</span> <span class="n">ti</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="n">generalized_inverse_CDF</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F0</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> 
                                         <span class="n">quantile</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">[</span><span class="n">pool</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#if start_age_densities is None:</span>
            <span class="c1">#    raise(Error(&#39;Cannot start delayed quantile computation,&#39;</span>
            <span class="c1">#                    &#39;since start_age_densities are missing.&#39;))</span>
            <span class="n">CDFs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_pool_age_distributions_single_value</span><span class="p">(</span>
                        <span class="n">start_age_densities</span><span class="p">)</span>
            <span class="n">CDF</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">CDFs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">])</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="n">generalized_inverse_CDF</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">CDF</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> 
                                         <span class="n">quantile</span><span class="o">*</span><span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">])</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">:]</span>

        <span class="n">t_max</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t_min</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span> <span class="o">=</span> <span class="n">t_max</span><span class="o">-</span><span class="n">t_min</span><span class="p">)</span>

        <span class="k">global</span> <span class="n">last_t</span><span class="p">,</span> <span class="n">last_res</span>
        <span class="n">last_t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">last_res</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">global</span> <span class="n">last_t</span><span class="p">,</span> <span class="n">last_res</span>
            
            <span class="n">t_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_val</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            
            <span class="c1"># rhs will be called twice with the same value apparently,  </span>
            <span class="c1"># we can use this to speed it up</span>
            <span class="k">if</span> <span class="n">t_val</span> <span class="o">==</span> <span class="n">last_t</span><span class="p">:</span> <span class="k">return</span> <span class="n">last_res</span>
            <span class="c1">#print(&#39;y&#39;, y, &#39;t&#39;, t_val)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">t_val</span> <span class="o">&lt;=</span> <span class="n">t_max</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t_val</span><span class="o">-</span><span class="n">t_min</span><span class="o">-</span><span class="n">pb</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1">#pb.n = t_val-t_min</span>
                <span class="c1">#pb.update(0)</span>
                <span class="n">pb</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">t_val</span><span class="o">-</span><span class="n">t_min</span><span class="o">-</span><span class="n">pb</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

<span class="c1">#            print(&#39;Quantile, line 2866&#39;)</span>
<span class="c1">#            print(&#39;y&#39;, y, &#39;t&#39;, t_val)</span>
        
            <span class="n">p_val</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">)[</span><span class="n">pool</span><span class="p">]</span>
            <span class="n">u_val</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">t_val</span><span class="p">)[</span><span class="n">pool</span><span class="p">]</span>
            <span class="n">F_vec</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">x_vec</span> <span class="o">=</span> <span class="n">vec_sol_func</span><span class="p">(</span><span class="n">t_val</span><span class="p">)</span><span class="c1">#.reshape((n,1))</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_func</span><span class="p">(</span><span class="n">vec_sol_func</span><span class="p">)(</span><span class="n">t_val</span><span class="p">)</span>

<span class="c1">#            print(&#39;B&#39;, B)</span>
<span class="c1">#            print(&#39;x&#39;, x_vec)</span>
<span class="c1">#            print(&#39;B*x&#39;, B.dot(x_vec))</span>
<span class="c1">#            print(&#39;p&#39;, p_val)</span>
<span class="c1">#            print(&#39;u&#39;, u_val)</span>
<span class="c1">#            print(&#39;F&#39;, F_vec)</span>
<span class="c1">#            print(&#39;B*F&#39;, B.dot(F_vec))</span>
<span class="c1">#            print(B.dot(F_vec)[pool])</span>
<span class="c1">#            print(B.dot(F_vec)[1])</span>

            <span class="c1">#if p_val == 0:</span>
                <span class="c1">#raise(Error(&#39;Division by zero during quantile computation.&#39;))</span>
            <span class="c1">#else:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">p_val</span><span class="o">*</span><span class="p">(</span><span class="n">u_val</span><span class="o">*</span><span class="p">(</span><span class="n">quantile</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
                        <span class="o">+</span><span class="n">quantile</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">x_vec</span><span class="p">)[</span><span class="n">pool</span><span class="p">])</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">F_vec</span><span class="p">)[</span><span class="n">pool</span><span class="p">]))</span>
            <span class="c1">#print(&#39;res&#39;, res)</span>
            <span class="c1">#print(&#39;---&#39;)</span>

            <span class="n">last_t</span> <span class="o">=</span> <span class="n">t_val</span>
            <span class="n">last_res</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1">#short_res = odeint(rhs, sv, times, atol=tol, mxstep=10000)</span>
        <span class="n">rhs2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t_val</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">rhs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">)</span>
        <span class="n">short_res</span> <span class="o">=</span> <span class="n">solve_ivp_pwc</span><span class="p">(</span>
            <span class="n">rhss</span>   <span class="o">=</span> <span class="p">(</span><span class="n">rhs2</span><span class="p">,),</span>
            <span class="n">y0</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sv</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">t_span</span> <span class="o">=</span> <span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">t_eval</span> <span class="o">=</span> <span class="n">times</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span><span class="o">.</span><span class="n">y</span>
        <span class="n">short_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">short_res</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">pb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">),))</span>
        <span class="n">res</span><span class="p">[:</span><span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">res</span><span class="p">[</span><span class="n">ti</span><span class="p">:]</span> <span class="o">=</span> <span class="n">short_res</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),))</span>

        <span class="k">if</span> <span class="n">check_time_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qs_ode</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">check_time_indices</span><span class="p">]</span>
            <span class="n">qs_pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">qs_ode</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ct_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">check_time_indices</span><span class="p">):</span>
                <span class="n">qs_pi</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">distribution_quantile</span><span class="p">(</span>
                    <span class="n">quantile</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">ct_index</span><span class="p">])[</span><span class="n">pool</span><span class="p">],</span> 
                    <span class="n">norm_const</span><span class="o">=</span><span class="n">soln</span><span class="p">[</span><span class="n">ct_index</span><span class="p">,</span> <span class="n">pool</span><span class="p">],</span>
                    <span class="n">start_value</span><span class="o">=</span><span class="n">qs_ode</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1">#, method=&#39;brentq&#39;, tol=1e-8):</span>

            <span class="n">print_quantile_error_statisctics</span><span class="p">(</span><span class="n">qs_ode</span><span class="p">,</span> <span class="n">qs_pi</span><span class="p">)</span>

        <span class="c1">#print(res)</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SmoothModelRun.system_age_distribution_quantiles_by_ode"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.system_age_distribution_quantiles_by_ode">[docs]</a>    <span class="k">def</span> <span class="nf">system_age_distribution_quantiles_by_ode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="p">,</span> 
            <span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check_time_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return system age distribution quantile over the time grid.</span>

<span class="sd">        The compuation is done by solving an ODE as soon as the system is </span>
<span class="sd">        nonempty.</span>
<span class="sd">        The initial value is obtained by computing the generalized inverse of </span>
<span class="sd">        the system age distribution by a numerical root search algorithm.</span>

<span class="sd">        Args:</span>
<span class="sd">            quantile (between 0 and 1): The relative share of mass that is </span>
<span class="sd">                considered to be left of the computed value. A value of ``0.5`` </span>
<span class="sd">                leads to the computation of the median of the distribution.</span>
<span class="sd">            pool (int): The number of the pool for which the age quantile is to </span>
<span class="sd">                be computed.</span>
<span class="sd">            start_age_densities (Python function): A function of age </span>
<span class="sd">                that returns a ``numpy.array`` containing the masses with the </span>
<span class="sd">                given age at time :math:`t_0`. </span>
<span class="sd">            F0 (Python function, optional): A function of age that returns a </span>
<span class="sd">                ``numpy.array`` containing the masses with age less than or </span>
<span class="sd">                equal to the age at time :math:`t_0`. </span>
<span class="sd">                It is fastest to provide ``F0``, otherwise ``F0`` will be </span>
<span class="sd">                computed by numerical integration of ``start_age_densities``.</span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            check_time_indices (numpy.array, optional): Indices of the tiime</span>
<span class="sd">                 grid on which the ODE result are checked against an explicit</span>
<span class="sd">                 solution computed by the pseudo-inverse of the cumulative </span>
<span class="sd">                distribution function.</span>
<span class="sd">                Defaults to ``None`` in which case no check is performed.</span>
<span class="sd">            kwargs: Passed to the ``solve_ivp``, e.g., ``method`` </span>
<span class="sd">                    or ``max_step``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Error: If ``start_age_densities`` is ``None``. </span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The computed quantile values over the time grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#soln = self.solve_old()</span>
        <span class="c1">#soln = self.solve()</span>
        <span class="n">vec_sol_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_solve_func_skew</span><span class="p">()</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="n">vec_sol_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
        <span class="c1"># check if system is empty at the beginning,</span>
        <span class="c1"># if so, then we use 0 as start value, otherwise</span>
        <span class="c1"># we need to compute it from F0 (preferably) or start_age_density</span>
        <span class="n">empty</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span> <span class="ow">and</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;start_age_densities must be given&#39;</span><span class="p">))</span>
        
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">original_times</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span> <span class="ow">and</span> <span class="n">F0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">start_age_densities</span>
            <span class="n">F0</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">p0</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="n">pool</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                                        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
        
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_age_density_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>
        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_pool_age_distributions_single_value</span><span class="p">(</span>
                <span class="n">start_age_densities</span><span class="o">=</span><span class="n">start_age_densities</span><span class="p">,</span> <span class="n">F0</span><span class="o">=</span><span class="n">F0</span><span class="p">)</span>
        <span class="c1">#sol_funcs = self.solve_single_value_old()</span>
        <span class="c1">#vec_sol_func = self.solve_func()</span>

        <span class="c1"># find last time index such that the system is empty --&gt; ti</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">content</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ti</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span> 
            <span class="n">ti</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span>
        
        <span class="k">if</span> <span class="n">content</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">ti</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ti</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),))</span>
  
        <span class="k">if</span> <span class="n">ti</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="n">generalized_inverse_CDF</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F0</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> 
                                         <span class="n">quantile</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#if start_age_densities is None:</span>
            <span class="c1">#    raise(Error(&#39;Cannot start delayed quantile computation,&#39;</span>
            <span class="c1">#                    &#39;since start_age_Densities are missing.&#39;))</span>
            <span class="n">CDFs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_system_age_distribution_single_value</span><span class="p">(</span>
                            <span class="n">start_age_densities</span><span class="p">)</span>
            <span class="n">CDF</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">CDFs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">])</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="n">generalized_inverse_CDF</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="n">quantile</span><span class="o">*</span><span class="n">soln</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">:]</span>

        <span class="n">t_max</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t_min</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span> <span class="o">=</span> <span class="n">t_max</span><span class="o">-</span><span class="n">t_min</span><span class="p">)</span>

        <span class="k">global</span> <span class="n">last_t</span><span class="p">,</span> <span class="n">last_res</span>
        <span class="n">last_t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">last_res</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">global</span> <span class="n">last_t</span><span class="p">,</span> <span class="n">last_res</span>
            
            <span class="n">t_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_val</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>

            <span class="c1"># rhs will be called twice with the same value apparently,  </span>
            <span class="c1"># we can use this to speed it up</span>
            <span class="k">if</span> <span class="n">t_val</span> <span class="o">==</span> <span class="n">last_t</span><span class="p">:</span> <span class="k">return</span> <span class="n">last_res</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">t_val</span> <span class="o">&lt;=</span> <span class="n">t_max</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t_val</span><span class="o">-</span><span class="n">t_min</span><span class="o">-</span><span class="n">pb</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1">#pb.n = t_val-t_min</span>
                <span class="c1">#pb.update(0)</span>
                <span class="n">pb</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">t_val</span><span class="o">-</span><span class="n">t_min</span><span class="o">-</span><span class="n">pb</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

            <span class="c1">#pb.update(t_val-t_min, n=0)</span>
            <span class="c1">#print()</span>
            <span class="c1">#print(&#39;y&#39;, y, &#39;t&#39;, t_val)</span>
        
            <span class="n">p_val</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">)</span>
            <span class="n">u_vec</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">t_val</span><span class="p">)</span>
            <span class="n">F_vec</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">x_vec</span> <span class="o">=</span> <span class="n">vec_sol_func</span><span class="p">(</span><span class="n">t_val</span><span class="p">)</span><span class="c1">#.reshape((n,1))</span>
            <span class="n">B</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">B_func</span><span class="p">(</span><span class="n">vec_sol_func</span><span class="p">)(</span><span class="n">t_val</span><span class="p">)</span>

            <span class="c1">#print(&#39;B&#39;, B)</span>
            <span class="c1">#print(&#39;x&#39;, x_vec)</span>
            <span class="c1">#print(&#39;B*x&#39;, B.dot(x_vec))</span>
            <span class="c1">#print(&#39;y&#39;, y)</span>
            <span class="c1">#print(&#39;t&#39;, t_val)</span>
            <span class="c1">#print(&#39;p&#39;, p_val)</span>
            <span class="c1">#print(&#39;u&#39;, u_vec)</span>
            <span class="c1">#print(&#39;F&#39;, F_vec)</span>
            <span class="c1">#print(&#39;B*F&#39;, B.dot(F_vec))</span>

            <span class="c1">#print(F_val/x_val.sum()*((B*x_val).sum()-(B*F_val).sum()))</span>
            <span class="c1">#if p_val == 0:</span>
            <span class="c1">#    raise(Error(&#39;Division by zero during quantile computation.&#39;))</span>
            <span class="c1">#else:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">p_val</span><span class="o">*</span><span class="p">(</span><span class="n">u_vec</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">quantile</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">+</span>
                            <span class="n">quantile</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">x_vec</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">F_vec</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="c1">#print(&#39;res&#39;, res)</span>

            <span class="n">last_t</span> <span class="o">=</span> <span class="n">t_val</span>
            <span class="n">last_res</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1">#short_res = odeint(rhs, sv, times, atol=tol, mxstep=10000)</span>
        <span class="n">rhs2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t_val</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">rhs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_val</span><span class="p">)</span>
        <span class="n">short_res</span> <span class="o">=</span> <span class="n">solve_ivp_pwc</span><span class="p">(</span>
            <span class="n">rhss</span>   <span class="o">=</span> <span class="p">(</span><span class="n">rhs2</span><span class="p">,),</span>
            <span class="n">y0</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sv</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">t_span</span> <span class="o">=</span> <span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">t_eval</span> <span class="o">=</span> <span class="n">times</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span><span class="o">.</span><span class="n">y</span>
        <span class="n">short_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">short_res</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">pb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">original_times</span><span class="p">),))</span>
        <span class="n">res</span><span class="p">[:</span><span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">res</span><span class="p">[</span><span class="n">ti</span><span class="p">:]</span> <span class="o">=</span> <span class="n">short_res</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),))</span>

        <span class="k">if</span> <span class="n">check_time_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qs_ode</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">check_time_indices</span><span class="p">]</span>
            <span class="n">qs_pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">qs_ode</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ct_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">check_time_indices</span><span class="p">):</span>
                <span class="n">qs_pi</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">distribution_quantile</span><span class="p">(</span>
                    <span class="n">quantile</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">ct_index</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> 
                    <span class="n">norm_const</span><span class="o">=</span><span class="n">soln</span><span class="p">[</span><span class="n">ct_index</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
                    <span class="n">start_value</span><span class="o">=</span><span class="n">qs_ode</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1">#, method=&#39;brentq&#39;, tol=1e-8):</span>

            <span class="n">print_quantile_error_statisctics</span><span class="p">(</span><span class="n">qs_ode</span><span class="p">,</span> <span class="n">qs_pi</span><span class="p">)</span>

        <span class="c1">#print(res)</span>
        <span class="k">return</span> <span class="n">res</span></div>


    <span class="c1">########## 14C methods #########</span>


<div class="viewcode-block" id="SmoothModelRun.to_14C_explicit"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.to_14C_explicit">[docs]</a>    <span class="k">def</span> <span class="nf">to_14C_explicit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_values_14C</span><span class="p">,</span> <span class="n">Fa_func</span><span class="p">,</span> <span class="n">decay_rate</span><span class="o">=</span><span class="mf">0.0001209681</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct and return a :class:`SmoothModelRun` instance that</span>
<span class="sd">           models the 14C component additional to the original model run.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            start_values_14C (numpy.nd_array, nr_pools): 14C start values.</span>
<span class="sd">            Fa_func (func(t)): returns atmospheric fraction to be multiplied with the input vector </span>
<span class="sd">            decay rate (float, optional): The decay rate to be used, defaults to</span>
<span class="sd">                ``0.0001209681`` (daily).</span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`SmoothModelRun`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">srm_14C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">to_14C_explicit</span><span class="p">(</span><span class="s1">&#39;lamda_14C&#39;</span><span class="p">,</span> <span class="s1">&#39;Fa_14C&#39;</span><span class="p">)</span>

        <span class="c1"># create SmoothModelRun for 14C</span>
        <span class="n">par_set_14C</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">par_set_14C</span><span class="p">[</span><span class="s1">&#39;lamda_14C&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">decay_rate</span>

        <span class="n">nr_pools</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">start_values_14C_cb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nr_pools</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">start_values_14C_cb</span><span class="p">[:</span><span class="n">nr_pools</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span>
        <span class="n">start_values_14C_cb</span><span class="p">[</span><span class="n">nr_pools</span><span class="p">:]</span> <span class="o">=</span> <span class="n">start_values_14C</span>
        <span class="n">times_14C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="c1">#Fa_atm = copy(atm_delta_14C)</span>
        <span class="c1">#Fa_atm[:,1] = Fa_atm[:,1]/1000 + 1</span>
        <span class="c1">#Fa_func = interp1d(Fa_atm[:,0], Fa_atm[:,1])</span>
        <span class="n">func_set_14C</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">function_string</span> <span class="o">=</span> <span class="s1">&#39;Fa_14C(&#39;</span> <span class="o">+</span> <span class="n">srm_14C</span><span class="o">.</span><span class="n">time_symbol</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
        <span class="n">func_set_14C</span><span class="p">[</span><span class="n">function_string</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fa_func</span>

        <span class="n">smr_14C</span> <span class="o">=</span> <span class="n">SmoothModelRun</span><span class="p">(</span>
            <span class="n">srm_14C</span><span class="p">,</span> 
            <span class="n">par_set_14C</span><span class="p">,</span>
            <span class="n">start_values_14C_cb</span><span class="p">,</span>
            <span class="n">times_14C</span><span class="p">,</span>
            <span class="n">func_set_14C</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">smr_14C</span></div>


    <span class="c1">########## private methods #########</span>


    <span class="k">def</span> <span class="nf">_solve_age_moment_system_single_value_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_order</span><span class="p">,</span> 
            <span class="n">start_age_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t0</span><span class="p">:</span>
                <span class="c1"># times x pools </span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">))</span>
                <span class="n">res</span><span class="p">[</span><span class="n">res</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">return</span> <span class="n">res</span>
            
            <span class="c1"># fixme: do we really want to cut off here? </span>
            <span class="c1"># This could be dangerous</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">t_max</span><span class="p">:</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t_max</span>

            <span class="n">new_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system_old</span><span class="p">(</span><span class="n">max_order</span><span class="p">,</span> 
                                                 <span class="n">start_age_moments</span><span class="p">,</span> 
                                                 <span class="n">times</span><span class="o">=</span><span class="n">new_times</span><span class="p">,</span> 
                                                 <span class="n">start_values</span><span class="o">=</span><span class="n">start_values</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">soln</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">func</span> 

    <span class="k">def</span> <span class="nf">_solve_age_moment_system_func</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> 
            <span class="n">max_order</span><span class="p">,</span> 
            <span class="n">start_age_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">start_values</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">):</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">soln</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_age_moment_system</span><span class="p">(</span>
            <span class="n">max_order</span><span class="p">,</span> 
            <span class="n">start_age_moments</span><span class="p">,</span> 
            <span class="c1">#times=new_times, </span>
            <span class="n">start_values</span><span class="o">=</span><span class="n">start_values</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">save_func</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">t0</span> <span class="ow">or</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">t_max</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                        times[0]&lt;t0 or times[-1]&gt;t_max: solve_ivp returns an interpolated</span>
<span class="s2">                        function, which does not check if the functions is called</span>
<span class="s2">                        with arguments outside the computed range, but we do. </span>
<span class="s2">                        &quot;&quot;&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">times</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">times</span> <span class="o">&lt;</span> <span class="n">t0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">times</span> <span class="o">&gt;</span> <span class="n">t_max</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                        t&lt;t0 or t&gt;t_max: solve_ivp returns an interpolated</span>
<span class="s2">                        function, which does not check if the functions is called</span>
<span class="s2">                        with arguments outside the computed range, but we do. </span>
<span class="s2">                        &quot;&quot;&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">save_func</span> 

    <span class="k">def</span> <span class="nf">_solve_age_moment_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_order</span><span class="p">,</span> 
            <span class="n">start_age_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># this function caches the interpolation function instead of the values</span>
        
        <span class="c1">#if max_order &lt; 1:</span>
        <span class="c1">#    raise(ValueError(&quot;For numerical consistency we use the age moment system only for order &gt;=1 (mean). Use solve instead!&quot;))</span>

        <span class="k">if</span> <span class="ow">not</span>  <span class="p">((</span><span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">start_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span> <span class="n">store</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="k">if</span> <span class="n">start_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">start_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span>

        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">start_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1">#print(start_values)</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;start_values should be a numpy array&quot;</span><span class="p">))</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="k">if</span> <span class="n">start_age_moments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_age_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_order</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        
        <span class="n">start_age_moments_list</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> 
                            <span class="p">[</span><span class="n">start_age_moments</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> 
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_age_moments</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]])</span>
       
        <span class="n">storage_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">start_age_moments_list</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">max_order</span><span class="p">,),)</span>

        <span class="c1"># return cached result if possible</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_previously_computed_age_moment_sol&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">storage_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_previously_computed_age_moment_sol</span><span class="p">:</span>
                    <span class="c1">#print(&#39;using cached age moment system:&#39;, storage_key)</span>
                    <span class="c1">#print(</span>
                    <span class="c1">#   self._previously_computed_age_moment_sol[storage_key])</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_previously_computed_age_moment_sol</span><span class="p">[</span><span class="n">storage_key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_previously_computed_age_moment_sol</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">srm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">state_vector</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">srm</span><span class="o">.</span><span class="n">age_moment_system</span><span class="p">(</span><span class="n">max_order</span><span class="p">)</span>
<span class="c1">#        print(&#39;---&#39;)</span>
<span class="c1">#        print(state_vector)</span>
<span class="c1">#        print(rhs)</span>
<span class="c1">#        input() </span>
        <span class="c1"># compute solution</span>
        <span class="n">new_start_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">max_order</span><span class="o">+</span><span class="mi">1</span><span class="p">),))</span>
        <span class="n">new_start_values</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_values</span><span class="p">)</span><span class="c1">#.reshape(n,) </span>
        <span class="n">new_start_values</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_age_moments_list</span><span class="p">)</span>

        <span class="n">soln</span><span class="p">,</span> <span class="n">sol_func</span> <span class="o">=</span> <span class="n">numsol_symbolical_system</span><span class="p">(</span>
            <span class="n">state_vector</span><span class="p">,</span>
            <span class="n">srm</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,</span>
            <span class="n">rhs</span><span class="p">,</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="p">],</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="p">],</span>
            <span class="n">new_start_values</span><span class="p">,</span> 
            <span class="n">times</span><span class="p">,</span>
            <span class="c1">#dense_output=True,</span>
            <span class="c1">#disc_times=self.disc_times</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">restrictionMaker</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="c1">#pe(&#39;soln[:,:]&#39;,locals())</span>
            <span class="n">restrictedSolutionArr</span><span class="o">=</span><span class="n">soln</span><span class="p">[:,:(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">]</span>
            <span class="k">def</span> <span class="nf">restrictedSolutionFunc</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">sol_func</span><span class="p">(</span><span class="n">t</span><span class="p">)[:(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">]</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">restrictedSolutionArr</span><span class="p">,</span><span class="n">restrictedSolutionFunc</span><span class="p">)</span>
            
        <span class="c1"># save all solutions for order &lt;= max_order</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="c1"># as it seems, if max_order is &gt; 0, the solution (solved with</span>
            <span class="c1"># max_order=0) is sligthly different from the part of first part</span>
            <span class="c1"># of the higher order system that corresponds als to the solution.</span>
            <span class="c1"># The difference is very small ( ~1e-5 ), but big</span>
            <span class="c1"># enough to cause numerical problems in functions depending on</span>
            <span class="c1"># the consistency of the solution and the state transition</span>
            <span class="c1"># operator.</span>

            <span class="c1">#consequently we do not save the solution</span>
            <span class="c1"># for orders less than max_order separately</span>
            <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="p">[</span><span class="n">max_order</span><span class="p">]:</span>
                <span class="n">shorter_start_age_moments_list</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">start_age_moments_list</span><span class="p">[:</span><span class="n">order</span><span class="o">*</span><span class="n">n</span><span class="p">])</span>
                <span class="c1">#print(start_age_moments_list)</span>
                <span class="c1">#print(shorter_start_age_moments_list)</span>
                <span class="n">storage_key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shorter_start_age_moments_list</span><span class="p">)</span> 
                                <span class="o">+</span> <span class="p">((</span><span class="n">order</span><span class="p">,),))</span>
                <span class="c1">#print(&#39;saving&#39;, storage_key)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_previously_computed_age_moment_sol</span><span class="p">[</span><span class="n">storage_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">restrictionMaker</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
                
                <span class="c1">#print(self._previously_computed_age_moment_sol[storage_key])</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">soln</span><span class="p">,</span> <span class="n">sol_func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_solve_age_moment_system_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_order</span><span class="p">,</span> 
            <span class="n">start_age_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1">#store = True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">start_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span> <span class="n">store</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="k">if</span> <span class="n">start_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">start_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span>

        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">start_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1">#print(start_values)</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;start_values should be a numpy array&quot;</span><span class="p">))</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="k">if</span> <span class="n">start_age_moments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_age_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_order</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        
        <span class="n">start_age_moments_list</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> 
                            <span class="p">[</span><span class="n">start_age_moments</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> 
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_age_moments</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]])</span>
       
        <span class="n">storage_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">start_age_moments_list</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">max_order</span><span class="p">,),)</span>

        <span class="c1"># return cached result if possible</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_previously_computed_age_moment_sol_old&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">storage_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_previously_computed_age_moment_sol_old</span><span class="p">:</span>
                    <span class="c1">#print(&#39;using cached age moment system:&#39;, storage_key)</span>
                    <span class="c1">#print(</span>
                    <span class="c1">#   self._previously_computed_age_moment_sol_old[storage_key])</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_previously_computed_age_moment_sol_old</span><span class="p">[</span><span class="n">storage_key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_previously_computed_age_moment_sol_old</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">srm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">state_vector</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">srm</span><span class="o">.</span><span class="n">age_moment_system</span><span class="p">(</span><span class="n">max_order</span><span class="p">)</span>
       
        <span class="c1"># compute solution</span>
        <span class="n">new_start_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">max_order</span><span class="o">+</span><span class="mi">1</span><span class="p">),))</span>
        <span class="n">new_start_values</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">start_values</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span> 
        <span class="n">new_start_values</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">start_age_moments_list</span><span class="p">))</span>

        <span class="n">soln</span><span class="o">=</span> <span class="n">numsol_symbolic_system_old</span><span class="p">(</span>
            <span class="n">state_vector</span><span class="p">,</span>
            <span class="n">srm</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,</span>
            <span class="n">rhs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="p">,</span>
            <span class="n">new_start_values</span><span class="p">,</span> 
            <span class="n">times</span>
        <span class="p">)</span>
        
        <span class="c1"># save all solutions for order &lt;= max_order</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">shorter_start_age_moments_list</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">start_age_moments_list</span><span class="p">[:</span><span class="n">order</span><span class="o">*</span><span class="n">n</span><span class="p">])</span>
                <span class="c1">#print(start_age_moments_list)</span>
                <span class="c1">#print(shorter_start_age_moments_list)</span>
                <span class="n">storage_key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shorter_start_age_moments_list</span><span class="p">)</span> 
                                <span class="o">+</span> <span class="p">((</span><span class="n">order</span><span class="p">,),))</span>
                <span class="c1">#print(&#39;saving&#39;, storage_key)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_previously_computed_age_moment_sol_old</span><span class="p">[</span><span class="n">storage_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">soln</span><span class="p">[:,:(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">])</span>
                <span class="c1">#print(self._previously_computed_age_moment_sol_old[storage_key])</span>

        <span class="k">return</span> <span class="n">soln</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">no_input_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">m</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">no_input_model</span>
        <span class="c1">#SmoothReservoirModel(</span>
        <span class="c1">#    m.state_vector,</span>
        <span class="c1">#    m.time_symbol,</span>
        <span class="c1">#    {},</span>
        <span class="c1">#    m.output_fluxes,</span>
        <span class="c1">#    m.internal_fluxes</span>
        <span class="c1">#)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_no_input_sol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># note that the solution of the no input system </span>
        <span class="c1"># only coincides with the (application of) </span>
        <span class="c1"># the statetransition operator if the system is linear</span>
        <span class="c1"># so this function can only compute the state transition operatro </span>
        <span class="c1"># for a linear(ized) system</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_saved_no_input_sol&#39;</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
            <span class="n">m_no_inputs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">no_input_model</span>
            
            <span class="n">no_inputs_num_rhs</span> <span class="o">=</span> <span class="n">numerical_rhs_old</span><span class="p">(</span>
                <span class="n">m_no_inputs</span><span class="o">.</span><span class="n">state_vector</span><span class="p">,</span> 
                <span class="n">m_no_inputs</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,</span> 
                <span class="n">m_no_inputs</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    
            <span class="k">def</span> <span class="nf">no_input_sol</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">start_vector</span><span class="p">):</span>
                <span class="p">(</span><span class="s1">&#39;nos&#39;</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">start_vector</span><span class="p">)</span>
                <span class="c1"># Start and end time too close together? Do not integrate!</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1e-14</span><span class="p">:</span> 
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_vector</span><span class="p">)</span>
                <span class="n">sv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_vector</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,))</span>

                <span class="k">return</span> <span class="n">odeint</span><span class="p">(</span><span class="n">no_inputs_num_rhs</span><span class="p">,</span> <span class="n">sv</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">mxstep</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">_saved_no_input_sol</span> <span class="o">=</span> <span class="n">no_input_sol</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_saved_no_input_sol</span>


<div class="viewcode-block" id="SmoothModelRun.initialize_state_transition_operator_cache"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.initialize_state_transition_operator_cache">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_state_transition_operator_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lru_maxsize</span><span class="p">,</span> <span class="n">lru_stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">custom_lru_cache</span> <span class="o">=</span> <span class="n">custom_lru_cache_wrapper</span><span class="p">(</span>
        	<span class="n">maxsize</span><span class="o">=</span><span class="n">lru_maxsize</span><span class="p">,</span> <span class="c1"># variable maxsize now for lru cache</span>
        	<span class="n">typed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        	<span class="n">stats</span><span class="o">=</span><span class="n">lru_stats</span> <span class="c1"># use custom statistics feature</span>
        <span class="p">)</span>
        
        <span class="n">nr_pools</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">t_min</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_max</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cache_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">nr_pools</span><span class="p">,</span> <span class="n">nr_pools</span><span class="p">))</span> 
        <span class="n">cache</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">(</span><span class="n">cache_times</span><span class="p">,</span> <span class="n">ca</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">myhash</span><span class="p">())</span>
        <span class="n">cache</span><span class="o">.</span><span class="n">_cached_phi_tmax</span> <span class="o">=</span> <span class="n">custom_lru_cache</span><span class="p">(</span><span class="n">phi_tmax</span><span class="p">)</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator_cache</span> <span class="o">=</span> <span class="n">cache</span> </div>


    <span class="c1">#fixme: </span>
    <span class="c1"># this method is not yet aware of the Cache class</span>
<div class="viewcode-block" id="SmoothModelRun.save_state_transition_operator_cache"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.save_state_transition_operator_cache">[docs]</a>    <span class="k">def</span> <span class="nf">save_state_transition_operator_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator_cache</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.load_state_transition_operator_cache"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.load_state_transition_operator_cache">[docs]</a>    <span class="k">def</span> <span class="nf">load_state_transition_operator_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="n">tmpCache</span> <span class="o">=</span> <span class="n">Cache</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">myhash</span><span class="p">()</span><span class="o">==</span><span class="n">tmpCache</span><span class="o">.</span><span class="n">myhash</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator_cache</span><span class="o">=</span><span class="n">tmpCache</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;State transition operator cache hash is different from the hash of the present model run and cannot be used. Please REMOVE THE CACHE FILE:&#39;</span><span class="o">+</span><span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.myhash"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.myhash">[docs]</a>    <span class="k">def</span> <span class="nf">myhash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Compute a hash considering SOME but NOT ALL properties of a</span>
<span class="sd">        model run. The function&#39;s main use is to detect saved state transition</span>
<span class="sd">        operator cashes that are no longer compatible with the model run object</span>
<span class="sd">        that wants to use them. This check is useful but NOT COMPREHENSIVE.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="k">def</span> <span class="nf">make_hash_sha256</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
            <span class="n">hasher</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">()</span>
            <span class="c1">#hasher.update(repr(make_hashable(o)).encode())</span>
            <span class="n">hasher</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">hasher</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">make_hash_sha256</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">frozendict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">input_fluxes</span><span class="p">),</span>    
                <span class="n">frozendict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">internal_fluxes</span><span class="p">),</span>    
                <span class="n">frozendict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">output_fluxes</span><span class="p">),</span>    
                <span class="n">ImmutableMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_vector</span><span class="p">),</span>
                <span class="c1"># to compute a hash of an arbitrary function object is difficult</span>
                <span class="c1"># in particular if the function depends on data.</span>
                <span class="n">frozendict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">,</span>
                <span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>   
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_x_phi_block_ode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x_block_name</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
        <span class="n">phi_block_name</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_x_phi_block_ode_cache&#39;</span><span class="p">)):</span>
            <span class="n">nr_pools</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
            
            <span class="n">block_ode</span> <span class="o">=</span> <span class="n">x_phi_ode</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="p">,),</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="p">,),</span>
                <span class="n">x_block_name</span><span class="p">,</span>
                <span class="n">phi_block_name</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x_phi_block_ode_cache</span> <span class="o">=</span> <span class="n">block_ode</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_phi_block_ode_cache</span><span class="p">,</span> <span class="n">x_block_name</span><span class="p">,</span> <span class="n">phi_block_name</span>

    <span class="k">def</span> <span class="nf">_state_transition_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,))</span>



    <span class="k">def</span> <span class="nf">_state_transition_operator_for_linear_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># this function could be used in a &quot;linear smooth model run class&quot;</span>
        <span class="c1"># At the moment it is only used by the tests to show</span>
        <span class="c1"># why a replacement was necessary for the general case</span>
        
        <span class="n">srm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">srm</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method can only be applied to linear systems. Maybe you have to linearize along a solution first?  ( Consider using the linearize method )&quot;</span>  <span class="p">)</span>

        <span class="k">if</span> <span class="n">t0</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Evaluation before t0 is not possible&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">t0</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> 
       
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">no_input_sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_input_sol</span>

        <span class="n">soln</span> <span class="o">=</span> <span class="p">(</span><span class="n">no_input_sol</span><span class="p">([</span><span class="n">t0</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>        
        
        <span class="c1"># avoid small negative values</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">soln</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">soln</span><span class="p">))</span>
        
    <span class="c1">#if self._state_transition_operator_cache is None:</span>
        <span class="c1">#    # do not use the cache, it has not yet been created</span>
        <span class="c1">#    #self.build_state_transition_operator_cache()</span>
        <span class="c1">#    soln = (no_input_sol([t0, t], x)).reshape((n,))        </span>
        <span class="c1">#else:</span>
        <span class="c1">#    # use the already created cache</span>
        <span class="c1">#    times = self.times</span>
        <span class="c1">#    t_min = times[0]</span>
        <span class="c1">#    t_max = times[-1]</span>
        <span class="c1">#    nc = self._cache_size</span>
    
        <span class="c1">#    cached_times = np.linspace(t_min, t_max, nc)</span>
        <span class="c1">#    ca = self._state_transition_operator_cache</span>
    
        <span class="c1">#    # find tm1</span>
        <span class="c1">#    tm1_ind = cached_times.searchsorted(t0)</span>
        <span class="c1">#    tm1 = cached_times[tm1_ind]</span>
    
        <span class="c1">#    # check if next cached time is already behind t</span>
        <span class="c1">#    if t &lt;= tm1: return no_input_sol([t0, t], x)</span>
    
        <span class="c1">#    # first integrate x to tm1: y = Phi(tm1, t_0)x</span>
        <span class="c1">#    y = (no_input_sol([t0, tm1], x)).reshape((n,1))</span>
    
        <span class="c1">#    step_size = (t_max-tm1)/(nc-1)</span>
        <span class="c1">#    if step_size &gt; 0:</span>
        <span class="c1">#        tm2_ind = np.int(np.min([np.floor((t-tm1)/step_size), nc-1]))</span>
        <span class="c1">#        tm2 = tm1 + tm2_ind*step_size</span>
    
        <span class="c1">#        #print(t, t0, t==t0, tm1_ind, tm1, tm2_ind, tm2, step_size) </span>
        <span class="c1">#        B = ca[tm1_ind,tm2_ind,:,:]</span>
        <span class="c1">#        #print(t, t0, tm1, tm2, step_size, B)</span>
        <span class="c1">#        </span>
        <span class="c1">#        z = np.dot(B, y)</span>
        <span class="c1">#    else:</span>
        <span class="c1">#        tm2 = tm1</span>
        <span class="c1">#        z = y</span>
        <span class="c1">#    #z = (no_input_sol([tm1, tm2], y)[-1]).reshape((n,))</span>
    
        <span class="c1">#    # integrate z to t: sol=Phi(t,tm2)*z</span>
        <span class="c1">#    soln = (no_input_sol([tm2, t],z)).reshape((n,))</span>
        <span class="c1">#</span>
        <span class="c1">#return np.maximum(soln, np.zeros_like(soln))</span>

    <span class="c1">#this function should be rewritten using the vector valued solution </span>
    <span class="k">def</span> <span class="nf">_flux_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_vec_symbolic</span><span class="p">):</span>
        <span class="c1">#sol = self.solve_old()</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">srm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        
        <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">srm</span><span class="o">.</span><span class="n">state_vector</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">srm</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>
        
        <span class="n">flux_vec_symbolic</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">flux_vec_symbolic</span><span class="p">,</span> <span class="nb">locals</span> <span class="o">=</span> <span class="n">_clash</span><span class="p">)</span>
        <span class="n">flux_vec_symbolic</span> <span class="o">=</span> <span class="n">flux_vec_symbolic</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="p">)</span>
        <span class="c1">#cut_func_set = {key[:key.index(&#39;(&#39;)]: val </span>
        <span class="c1">#                    for key, val in self.func_set.items()}</span>
        <span class="n">cut_func_set</span><span class="o">=</span><span class="n">make_cut_func_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="p">)</span>
        <span class="n">flux_vec_fun</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> 
                                <span class="n">flux_vec_symbolic</span><span class="p">,</span> 
                                <span class="n">modules</span><span class="o">=</span><span class="p">[</span><span class="n">cut_func_set</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">])</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">sol</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">pool</span><span class="p">]</span> <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">times</span><span class="p">[</span><span class="n">ti</span><span class="p">]]</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">flux_vec_fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>

        <span class="k">return</span> <span class="n">res</span>


    <span class="c1">##### age density methods #####</span>


    <span class="k">def</span> <span class="nf">_age_densities_1_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_age_densities</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># for part that comes from initial value</span>
        <span class="k">if</span> <span class="n">start_age_densities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># all mass is assumed to have age 0 at the beginning</span>
            <span class="k">def</span> <span class="nf">start_age_densities</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">)</span>

        <span class="c1"># cut off negative ages in start_age_densities</span>
        <span class="k">def</span> <span class="nf">p0</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">return</span> <span class="n">start_age_densities</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">,))</span>

        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span><span class="c1">#_for_linear_systems</span>
 
        <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#ppp = lambda a, t: self._state_transition_operator(t,t0,p0(a-(t-t0)))</span>
        <span class="k">def</span> <span class="nf">ppp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="c1">#print(&#39;iv: &#39;, a, t)</span>

            <span class="c1">#fixme: cut off accidental negative values</span>
            <span class="c1">#print(&#39;Y&#39;, a-(t-t0), p0(a-t-t0))</span>
            <span class="c1">#print(&#39;smr 3821 ppp&#39;, t, t0, a, a-(t-t0))</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">Phi</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">p0</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">))),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1">#print(&#39;ppp:&#39;, res)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">ppp</span>

    <span class="c1"># return a function p1 that takes an age np.array</span>
    <span class="c1"># and gives back an nd array (age, time, pool)</span>
    <span class="k">def</span> <span class="nf">_age_densities_1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_age_densities</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># for part that comes from initial value</span>

        <span class="n">ppp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_1_single_value</span><span class="p">(</span><span class="n">start_age_densities</span><span class="p">)</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ppp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ages</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ages</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">p1</span>
        
    <span class="k">def</span> <span class="nf">_age_densities_2_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># for part that comes from the input function u</span>
       
        <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>
        <span class="c1">#u = lambda x: np.array([1,2])</span>

        <span class="k">def</span> <span class="nf">ppp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="c1">#print(&#39;input&#39;, a, t)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">u_val</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
                <span class="c1">#print(&#39;u_val&#39;, u_val)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">u_val</span><span class="p">)</span>

            <span class="c1">#fixme: cut off accidental negative values</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1">#print(&#39;ppp:&#39;, res)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">ppp</span>

    <span class="c1"># returns a function p2 that takes an age array &quot;ages&quot; as argument</span>
    <span class="c1"># and gives back a three-dimensional ndarray (ages x times x pools)</span>
    <span class="k">def</span> <span class="nf">_age_densities_2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># for part that comes from the input function u</span>
        <span class="n">ppp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age_densities_2_single_value</span><span class="p">()</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ppp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ages</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ages</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">p2</span>


    <span class="c1">##### plotting methods #####</span>
    
    
    <span class="k">def</span> <span class="nf">_density_plot_plotly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">ages</span><span class="p">,</span> <span class="n">age_stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_stride</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="n">strided_field</span> <span class="o">=</span> <span class="n">stride</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="p">(</span><span class="n">age_stride</span><span class="p">,</span> <span class="n">time_stride</span><span class="p">))</span>
        <span class="n">strided_ages</span> <span class="o">=</span> <span class="n">stride</span><span class="p">(</span><span class="n">ages</span><span class="p">,</span> <span class="n">age_stride</span><span class="p">)</span>
        <span class="n">strided_times</span> <span class="o">=</span> <span class="n">stride</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">time_stride</span><span class="p">)</span>
 
        <span class="n">surfacecolor</span> <span class="o">=</span> <span class="n">strided_field</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">strided_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">strided_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">surfacecolor</span><span class="p">[</span><span class="n">ai</span><span class="p">,</span><span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">ai</span> <span class="o">-</span> <span class="n">ti</span><span class="p">)</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">go</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">strided_times</span><span class="p">,</span> 
                           <span class="n">y</span> <span class="o">=</span> <span class="n">strided_ages</span><span class="p">,</span> 
                           <span class="n">z</span> <span class="o">=</span> <span class="n">strided_field</span><span class="p">,</span> 
                           <span class="n">showscale</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                           <span class="n">surfacecolor</span> <span class="o">=</span> <span class="n">surfacecolor</span><span class="p">,</span> 
                           <span class="n">colorscale</span> <span class="o">=</span> <span class="s1">&#39;Rainbow&#39;</span><span class="p">)]</span>
        
        <span class="n">tickvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">strided_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">strided_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">ticktext</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tickvals</span><span class="p">]</span>
        <span class="n">tickvals</span> <span class="o">=</span> <span class="o">-</span><span class="n">tickvals</span>
        
        <span class="n">layout</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span>
            <span class="n">width</span> <span class="o">=</span> <span class="mi">800</span><span class="p">,</span>
            <span class="n">height</span> <span class="o">=</span> <span class="mi">800</span><span class="p">,</span>
            <span class="n">scene</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">xaxis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Time&#39;</span><span class="p">,</span>
                    <span class="n">tickmode</span> <span class="o">=</span> <span class="s1">&#39;array&#39;</span><span class="p">,</span>
                    <span class="n">tickvals</span> <span class="o">=</span> <span class="n">tickvals</span><span class="p">,</span>
                    <span class="n">ticktext</span> <span class="o">=</span> <span class="n">ticktext</span>
                    <span class="c1">#range = [-times[0], -times[-1]]</span>
                <span class="p">),</span>
                <span class="n">yaxis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Age&#39;</span><span class="p">,</span>
                    <span class="nb">range</span> <span class="o">=</span> <span class="p">[</span><span class="n">ages</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ages</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="p">),</span>
                <span class="n">zaxis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Mass&#39;</span><span class="p">,</span>
                    <span class="nb">range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">strided_field</span><span class="p">)]</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">layout</span>


    <span class="c1">## plot helper methods ##</span>

    <span class="c1">#fixme: unit treatment disabled</span>
    <span class="k">def</span> <span class="nf">_add_time_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="c1">#if self.model.time_unit:</span>
        <span class="c1">#    label += r&quot;$\quad(\mathrm{&quot; + latex(self.model.time_unit) + &quot;})$&quot;</span>

        <span class="k">return</span> <span class="n">label</span>

    <span class="k">def</span> <span class="nf">_add_content_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="c1">#if self.model.content_unit:</span>
        <span class="c1">#    label +=r&quot;$\quad(\mathrm{&quot; + latex(self.model.content_unit) + &quot;})$&quot;</span>

        <span class="k">return</span> <span class="n">label</span>

    <span class="k">def</span> <span class="nf">_add_flux_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="c1">#if self.model.content_unit and self.model.time_unit:</span>
        <span class="c1">#    label += r&quot;$\quad(\mathrm{&quot; + latex(self.model.content_unit) </span>
        <span class="c1">#    label += &quot;/&quot; + latex(self.model.time_unit) + &quot;})$&quot;</span>
        
        <span class="k">return</span> <span class="n">label</span>


    <span class="c1">## flux helper functions ##</span>

 
    <span class="c1">#fixme: test and move</span>
    

    <span class="k">def</span> <span class="nf">_flux_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr_dict</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="c1">#sol_funcs = self.sol_funcs()</span>
        <span class="n">sol_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol_funcs</span><span class="p">()</span>
        <span class="n">flux_funcs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">state_variables</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">time_symbol</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">expr_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
                <span class="c1"># in this case (constant flux) lambdify for some reason </span>
                <span class="c1"># does not return a vectorized function but one that</span>
                <span class="c1"># allways returns a number even when it is called with </span>
                <span class="c1"># an array argument. We therfore create such a function </span>
                <span class="c1"># ourselves</span>
                <span class="n">flux_funcs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">const_of_t_maker</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># fixme mm 11-5-2018 </span>
                <span class="c1"># the sympify in the next line should be unnecesary since </span>
                <span class="c1"># the expressions are already expressions and not strings</span>
                <span class="c1"># and now also not Numbers</span>
                <span class="c1">#o_par = sympify(expression, locals=_clash).subs(self.parameter_dict)</span>
                <span class="n">o_par</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="p">)</span>
                <span class="n">cut_func_set</span> <span class="o">=</span> <span class="n">make_cut_func_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_set</span><span class="p">)</span>
                <span class="n">ol</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">o_par</span><span class="p">,</span> <span class="n">modules</span> <span class="o">=</span> <span class="p">[</span><span class="n">cut_func_set</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">])</span>
                <span class="c1">#ol = numerical_function_from_expression(expression,tup,self.parameter_dict,self.func_set) </span>
                <span class="n">flux_funcs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_of_t_maker</span><span class="p">(</span><span class="n">sol_funcs</span><span class="p">,</span> <span class="n">ol</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">flux_funcs</span>


    <span class="c1">## temporary ##</span>


    <span class="k">def</span> <span class="nf">_FTTT_lambda_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="n">u_norm</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">u_norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">end</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Phi</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">u_norm</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">result</span>


    <span class="k">def</span> <span class="nf">_FTTT_lambda_bar_R</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Interval boundaries out of bounds&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Starting time must not be later then ending time&#39;</span><span class="p">))</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">end</span>
        <span class="n">u_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>
        <span class="c1">#soln_func = self.solve_single_value_old()</span>
        <span class="n">vec_soln_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">vec_soln_func</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
        <span class="n">x0_norm</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        
        <span class="n">A</span> <span class="o">=</span> <span class="n">x0_norm</span><span class="o">*</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_FTTT_lambda_bar</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
        
        <span class="c1">#print(&#39;A&#39;, A)</span>

        <span class="k">def</span> <span class="nf">B_integrand</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">u_func</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">u_norm</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">u_norm</span><span class="o">*</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_FTTT_lambda_bar</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">B_integrand</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#print(&#39;B&#39;, B)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">x0_norm</span><span class="o">*</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span>
        <span class="c1">#print(&#39;C&#39;, C)</span>

        <span class="k">def</span> <span class="nf">D_integrand</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">u_norm</span> <span class="o">=</span> <span class="n">u_func</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">u_norm</span><span class="o">*</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">D_integrand</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#print(&#39;D&#39;, D)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="o">+</span><span class="n">B</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">C</span><span class="o">+</span><span class="n">D</span><span class="p">)</span>

  
    <span class="k">def</span> <span class="nf">_FTTT_T_bar_R</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Interval boundaries out of bounds&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Starting time must not be later then ending time&#39;</span><span class="p">))</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">end</span>
        <span class="n">u_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>

        <span class="c1">#soln_func = self.solve_single_value_old()</span>
        <span class="n">vec_soln_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">vec_soln_func</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
        <span class="n">x0_norm</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">x0_norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">x0_norm</span><span class="o">*</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_FTTT_lambda_bar</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1">#print(&#39;A&#39;, A)</span>

        <span class="k">def</span> <span class="nf">B_integrand</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">u_func</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">u_norm</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">u_norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">u_norm</span><span class="o">*</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_FTTT_lambda_bar</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">B_integrand</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#print(&#39;B&#39;, B)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">x0_norm</span><span class="o">*</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span>
        <span class="c1">#print(&#39;C&#39;, C)</span>

        <span class="k">def</span> <span class="nf">D_integrand</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">u_norm</span> <span class="o">=</span> <span class="n">u_func</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">u_norm</span><span class="o">*</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">D_integrand</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#print(&#39;D&#39;, D)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="o">+</span><span class="n">B</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">C</span><span class="o">+</span><span class="n">D</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_FTTT_lambda_bar_S</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="c1"># for Martin Rasmussens surrogate system</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Interval boundaries out of bounds&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Starting time must not be later than ending time&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> 
        <span class="c1">#soln_func = self.solve_single_value_old()</span>
        <span class="n">vec_soln_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">vec_soln_func</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">vec_soln_func</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>

        <span class="n">z0</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">z1</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="n">u_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>

        <span class="c1"># function to minimize during Newton to find lambda_bar_S</span>
        <span class="c1"># g seems to have huge numerical issues</span>
        <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">lamda</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                <span class="c1"># RHS in the surrogate system</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">lamda</span><span class="o">*</span><span class="n">z</span><span class="o">+</span><span class="nb">sum</span><span class="p">(</span><span class="n">u_func</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        
            <span class="c1"># solve the system with current lambda</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">z0</span><span class="p">,</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">])</span>

            <span class="c1"># return the distance of the current final time value</span>
            <span class="c1"># from the desired z1</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">z1</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="c1"># g2 seems to work much better</span>
        <span class="k">def</span> <span class="nf">g2</span><span class="p">(</span><span class="n">lamda</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lamda</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">137</span>

            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">lamda</span><span class="o">*</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">s</span><span class="p">))</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">u_func</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                <span class="c1">#print(lamda, res, u_func(s), t1, s)</span>
                <span class="k">return</span> <span class="n">res</span>

            <span class="n">int_res</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">z0_remaining</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">lamda</span><span class="o">*</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">))</span><span class="o">*</span><span class="n">z0</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">z0_remaining</span><span class="o">&lt;</span><span class="mf">1e-08</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">z0_remaining</span><span class="p">):</span>
                <span class="n">z0_remaining</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">z0_remaining</span><span class="o">-</span><span class="n">z1</span><span class="o">+</span><span class="n">int_res</span>
            <span class="c1">#print(lamda, z0_remaining, z1, int_res, res)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="c1"># return lambda_bar_S after optimization</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1">#res = newton(g, 0.5, maxiter=5000)</span>
            <span class="c1">#res = newton(g2, 1.5, maxiter=500)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">brentq</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;optimization aborted&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="k">if</span> <span class="n">res</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span>
            

    <span class="k">def</span> <span class="nf">_calculate_steady_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1">#fixme: should be possible only for autonomous, possibly nonlinear,</span>
    <span class="c1"># models</span>
    <span class="c1">#fixme: test?</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_dict</span><span class="p">),</span> 
                   <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_vector</span><span class="p">,</span> 
                   <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">return_ss</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ss_i</span> <span class="ow">in</span> <span class="n">ss</span><span class="p">:</span>
            <span class="n">add</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ss_i</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time_symbol</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="n">add</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">add</span><span class="p">:</span>
                <span class="n">return_ss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ss_i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">return_ss</span>


    <span class="k">def</span> <span class="nf">_FTTT_lambda_bar_R_left_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t0</span><span class="p">):</span>
        <span class="c1">#B0 = self.B(t0)</span>
        <span class="n">vec_sol_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="n">B0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_func</span><span class="p">()(</span><span class="n">t0</span><span class="p">)</span>
        <span class="n">iv</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_values</span><span class="p">)</span> <span class="c1"># column vector</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">iv</span><span class="p">))</span><span class="o">*</span><span class="n">B0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">iv</span><span class="o">/</span><span class="n">mpmath</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1">## new FTTT approach ##</span>

    <span class="k">def</span> <span class="nf">_alpha_s_i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">t1</span><span class="p">):</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="n">e_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">)</span>
        <span class="n">e_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">e_i</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            
    <span class="k">def</span> <span class="nf">_alpha_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="n">vec_norm</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">vec</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">vec_norm</span>

    <span class="k">def</span> <span class="nf">_EFFTT_s_i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">alpha_s_i</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>
        <span class="k">if</span> <span class="n">alpha_s_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha_s_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha_s_i</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">t1</span><span class="p">)</span>
       
        <span class="n">e_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">)</span>
        <span class="n">e_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">def</span> <span class="nf">F_FTT_i</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">e_i</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">integrand</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">F_FTT_i</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">alpha_s_i</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t1</span><span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">epsabs</span><span class="o">=</span><span class="mf">1.5e-03</span><span class="p">,</span> <span class="n">epsrel</span><span class="o">=</span><span class="mf">1.5e-03</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_TR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span> <span class="c1"># v is the remaining vector, not normalized</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">Phi_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">e_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">e_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">Phi_matrix</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">e_i</span><span class="p">)</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">logm</span><span class="p">(</span><span class="n">Phi_matrix</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span>
        <span class="n">A_inv</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">v_normed</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">v</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
   
        <span class="k">return</span> <span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">o</span> <span class="o">@</span> <span class="n">A_inv</span> <span class="o">@</span> <span class="n">v_normed</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_FTTT_finite_plus_remaining</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">t0</span><span class="p">:</span>
            <span class="c1">#soln_func = self.solve_single_value_old()</span>
            <span class="n">vec_soln_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">vec_soln_func</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">u_func</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">vec_norm</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">vec_norm</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator</span>

            <span class="c1"># the finite time part</span>
            <span class="n">finite</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span><span class="p">):</span>
                <span class="n">alpha_s_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha_s_i</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">t1</span><span class="p">)</span>
                <span class="n">EFFTT_s_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EFFTT_s_i</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">alpha_s_i</span><span class="p">)</span>
                <span class="n">finite</span> <span class="o">+=</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha_s_i</span> <span class="o">*</span> <span class="n">EFFTT_s_i</span>
            
            <span class="c1"># the part for the remaining mass</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">t1</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">Phi</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">vec</span><span class="p">)</span> <span class="c1"># remaining mass at time t1</span>
                <span class="n">alpha_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha_s</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span>
                <span class="n">remaining</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha_s</span><span class="p">)</span> <span class="o">*</span> <span class="n">vec_norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TR</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remaining</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">return</span> <span class="n">finite</span> <span class="o">+</span> <span class="n">remaining</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>


    <span class="k">def</span> <span class="nf">_FTTT_conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t0</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Interval boundaries out of bounds&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">t0</span> <span class="o">&gt;=</span> <span class="n">t1</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Starting time must be earlier then ending time&#39;</span><span class="p">))</span>
        
        <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FTTT_finite_plus_remaining</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">B_integrand</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FTTT_finite_plus_remaining</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">B_integrand</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">epsabs</span><span class="o">=</span><span class="mf">1.5e-03</span><span class="p">,</span> <span class="n">epsrel</span><span class="o">=</span><span class="mf">1.5e-03</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#soln_func = self.solve_single_value_old()</span>
        <span class="n">vec_soln_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">vec_soln_func</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
        <span class="n">x0_norm</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">x0_norm</span><span class="o">*</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span>
        
        <span class="n">u_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_input_vector_func</span><span class="p">()</span>
        <span class="k">def</span> <span class="nf">D_integrand</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">u_norm</span> <span class="o">=</span> <span class="n">u_func</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">u_norm</span><span class="o">*</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">D_integrand</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="o">+</span><span class="n">B</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">C</span><span class="o">+</span><span class="n">D</span><span class="p">)</span>


        <span class="c1">#### Important again ####</span>


<div class="viewcode-block" id="SmoothModelRun.Phi_func"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.Phi_func">[docs]</a>    <span class="k">def</span> <span class="nf">Phi_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># note that the functions used to produce the matrix </span>
        <span class="c1"># self.Phi are cached (if the cache is initialized)</span>
        <span class="c1"># so that the repeated calls by the following lambda</span>
        <span class="c1"># are actually cheap</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Phi</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.Phi"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.Phi">[docs]</a>    <span class="k">def</span> <span class="nf">Phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="n">nr_pools</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">start_Phi_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nr_pools</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">S</span> <span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Evaluation before S is not possible&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">S</span> <span class="o">==</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">start_Phi_2d</span>
        
        <span class="n">solve_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="n">block_ode</span><span class="p">,</span> <span class="n">x_block_name</span><span class="p">,</span> <span class="n">phi_block_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_phi_block_ode</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;_state_transition_operator_cache&#39;</span><span class="p">):</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_transition_operator_cache</span>
            <span class="n">cache_times</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">keys</span>
            <span class="n">S_phi_ind</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">phi_ind</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
            <span class="n">T_phi_ind</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">phi_ind</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
            <span class="n">my_phi_tmax</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">_cached_phi_tmax</span> 
            <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t_max</span><span class="p">):</span>
                <span class="n">x_s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">solve_func</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">my_phi_tmax</span><span class="p">(</span>
                    <span class="n">s</span><span class="p">,</span>
                    <span class="n">t_max</span><span class="p">,</span>
                    <span class="n">block_ode</span><span class="p">,</span>
                    <span class="n">x_s</span><span class="p">,</span>
                    <span class="n">x_block_name</span><span class="p">,</span>
                    <span class="n">phi_block_name</span>
                <span class="p">)(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">S_phi_ind</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">phi_ind</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
            <span class="n">T_phi_ind</span>  <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">phi_ind</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

<span class="c1">#            t_max = self.times[-1]</span>
            <span class="n">t_max</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">end_time_from_phi_ind</span><span class="p">(</span><span class="n">T_phi_ind</span><span class="p">)</span>

            <span class="c1"># catch the corner cases where the cache is useless.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">T_phi_ind</span><span class="o">-</span><span class="n">S_phi_ind</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">phi</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">cache</span><span class="o">.</span><span class="n">end_time_from_phi_ind</span><span class="p">(</span><span class="n">T_phi_ind</span><span class="p">))</span>
            <span class="n">tm1</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">end_time_from_phi_ind</span><span class="p">(</span><span class="n">S_phi_ind</span><span class="p">)</span>
        
            <span class="c1">## first integrate to tm1: </span>
            <span class="k">if</span> <span class="n">tm1</span> <span class="o">!=</span> <span class="n">S</span><span class="p">:</span>
                <span class="n">phi_tm1_S</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="n">tm1</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">tm1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">phi_tm1_S</span> <span class="o">=</span> <span class="n">start_Phi_2d</span>

            <span class="n">phi_T_tm1</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">tm1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">phi_T_tm1</span><span class="p">,</span> <span class="n">phi_tm1_S</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
                <span class="n">x_s</span> <span class="o">=</span> <span class="n">solve_func</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">start_Phi_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nr_pools</span><span class="p">)</span>
                <span class="n">start_blocks</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">x_block_name</span><span class="p">,</span> <span class="n">x_s</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">phi_block_name</span><span class="p">,</span> <span class="n">start_Phi_2d</span><span class="p">)</span> 
                <span class="p">]</span>
                <span class="n">blivp</span> <span class="o">=</span> <span class="n">block_ode</span><span class="o">.</span><span class="n">blockIvp</span><span class="p">(</span><span class="n">start_blocks</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">blivp</span><span class="o">.</span><span class="n">block_solve</span><span class="p">(</span><span class="n">t_span</span><span class="o">=</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">))[</span><span class="n">phi_block_name</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
            
            <span class="k">return</span> <span class="n">phi</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.fake_discretized_Bs"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.fake_discretized_Bs">[docs]</a>    <span class="k">def</span> <span class="nf">fake_discretized_Bs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> 
        <span class="k">if</span> <span class="n">data_times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        
        <span class="n">nr_pools</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_pools</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
        <span class="n">Bs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr_pools</span><span class="p">,</span> <span class="n">nr_pools</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">Bs</span><span class="p">[</span><span class="n">k</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Phi</span><span class="p">(</span><span class="n">data_times</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">data_times</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">Bs</span></div>

<div class="viewcode-block" id="SmoothModelRun.acc_net_internal_flux_matrix"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.acc_net_internal_flux_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">acc_net_internal_flux_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>    
        <span class="k">if</span> <span class="n">data_times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="n">x_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">x_func</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>

        <span class="n">Bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fake_discretized_Bs</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">net_Fs_from_discrete_Bs_and_xs</span><span class="p">(</span><span class="n">Bs</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.acc_net_external_output_vector"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.acc_net_external_output_vector">[docs]</a>    <span class="k">def</span> <span class="nf">acc_net_external_output_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data_times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="n">x_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">x_func</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
        
        <span class="n">Bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fake_discretized_Bs</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">net_Rs_from_discrete_Bs_and_xs</span><span class="p">(</span><span class="n">Bs</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmoothModelRun.acc_net_external_input_vector"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.acc_net_external_input_vector">[docs]</a>    <span class="k">def</span> <span class="nf">acc_net_external_input_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>    
        <span class="k">if</span> <span class="n">data_times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="n">x_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">x_func</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
        
        <span class="n">Bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fake_discretized_Bs</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">net_Us_from_discrete_Bs_and_xs</span><span class="p">(</span><span class="n">Bs</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SmoothModelRun.fake_net_discretized_output"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.fake_net_discretized_output">[docs]</a>    <span class="k">def</span> <span class="nf">fake_net_discretized_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_times</span><span class="p">):</span>
        <span class="n">x_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">x_func</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
    
        <span class="n">net_Fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc_net_internal_flux_matrix</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
        <span class="n">net_Rs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc_net_external_output_vector</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
        <span class="n">net_Us</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc_net_external_input_vector</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">xs</span><span class="p">,</span> <span class="n">net_Us</span><span class="p">,</span> <span class="n">net_Fs</span><span class="p">,</span> <span class="n">net_Rs</span></div>

<div class="viewcode-block" id="SmoothModelRun.fake_gross_discretized_output"><a class="viewcode-back" href="../../CompartmentalSystems.html#CompartmentalSystems.smooth_model_run.SmoothModelRun.fake_gross_discretized_output">[docs]</a>    <span class="k">def</span> <span class="nf">fake_gross_discretized_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_times</span><span class="p">):</span>
        <span class="c1">## prepare some fake output data</span>
        <span class="c1">#x = self.solve_single_value_old()</span>
        <span class="n">x_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_func</span><span class="p">()</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">x_func</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
    
        <span class="n">gross_Fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc_gross_internal_flux_matrix</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
        <span class="n">gross_Rs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc_gross_external_output_vector</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
        <span class="n">gross_Us</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc_gross_external_input_vector</span><span class="p">(</span><span class="n">data_times</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">xs</span><span class="p">,</span> <span class="n">gross_Us</span><span class="p">,</span> <span class="n">gross_Fs</span><span class="p">,</span> <span class="n">gross_Rs</span></div></div>

        

 
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">CompartmentalSystems</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Holger Metzler, Markus Müller.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>